/**
 * Base Agent Tools
 *
 * Shared tools available to all agent types:
 * - check_entity_memory
 * - flag_for_human_review
 * - generate_summary
 */

import { registerTool } from "../reasoning/tool-executor"
import { retrieveMemories } from "../memory/memory-retriever"
import type { ToolContext, ToolResult } from "../types"

export function registerBaseTools(): void {
  registerTool({
    name: "check_entity_memory",
    description: "Check prior knowledge about a specific vendor, account, or counterparty. Returns any stored memories matching the entity key.",
    inputSchema: { entityKey: "string" },
    handler: async (input: unknown, context: ToolContext): Promise<ToolResult> => {
      const { entityKey } = input as { entityKey: string }
      const memories = await retrieveMemories({
        organizationId: context.organizationId,
        agentDefinitionId: context.agentDefinitionId,
        entityKeys: [entityKey],
        maxMemories: 5,
      })

      return {
        success: true,
        data: {
          memoriesFound: memories.length,
          memories: memories.map(m => ({
            scope: m.scope,
            category: m.category,
            description: m.content.description,
            confidence: Math.round(m.confidence * 100),
            confirmations: `${m.correctCount}/${m.totalCount}`,
          })),
        },
      }
    },
  })

  registerTool({
    name: "flag_for_human_review",
    description: "Flag specific exception items for human review with an explanation. Use when confidence is low or the item is genuinely new.",
    inputSchema: { exceptionIndices: "number[]", reason: "string" },
    handler: async (input: unknown, _context: ToolContext): Promise<ToolResult> => {
      const { exceptionIndices, reason } = input as { exceptionIndices: number[]; reason: string }
      return {
        success: true,
        data: {
          flaggedCount: exceptionIndices.length,
          indices: exceptionIndices,
          reason,
        },
      }
    },
  })

  registerTool({
    name: "generate_summary",
    description: "Generate an executive summary of the reconciliation results. Call this as the final step before finishing.",
    inputSchema: { includeRecommendations: "boolean?" },
    handler: async (input: unknown, context: ToolContext): Promise<ToolResult> => {
      const { includeRecommendations } = input as { includeRecommendations?: boolean }

      // The summary will be generated by the caller using execution state
      // This tool is a signal to the reasoning loop that it should wrap up
      return {
        success: true,
        data: {
          action: "summary_requested",
          includeRecommendations: includeRecommendations ?? true,
        },
      }
    },
  })
}
