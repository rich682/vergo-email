// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  // "native" = your local machine (Mac/Windows/Linux)
  // "debian-openssl-3.0.x" = Cloud Run production (node:18-slim is Debian-based)
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  MANAGER
  MEMBER
  VIEWER
}

// TaskType enum removed - tasks are now type-agnostic
// Reports are available on any task via reportDefinitionId

enum TaskStatus {
  // Current active statuses
  NO_REPLY // No reply received yet (default for new requests)
  REPLIED // Reply received from contact
  COMPLETE // Task marked as complete (manual action)
  SEND_FAILED // Email delivery failed (bounce, rejection, provider error)
  // Legacy statuses (kept for backward compatibility with existing data)
  IN_PROGRESS // @deprecated - maps to NO_REPLY
  FULFILLED // @deprecated - maps to COMPLETE
  AWAITING_RESPONSE // @deprecated - maps to NO_REPLY
  HAS_ATTACHMENTS // @deprecated - maps to REPLIED
  VERIFYING // @deprecated - maps to REPLIED
  REJECTED // @deprecated - maps to COMPLETE
  FLAGGED // @deprecated - maps to NO_REPLY
  MANUAL_REVIEW // @deprecated - maps to NO_REPLY
  ON_HOLD // @deprecated - maps to NO_REPLY
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageChannel {
  EMAIL
  SMS
}

enum EmailProvider {
  GMAIL
  MICROSOFT
  GENERIC_SMTP
}

enum CampaignType {
  W9
  COI
  EXPENSE
  TIMESHEET
  INVOICE
  RECEIPT
  CUSTOM
}

enum EmailDraftStatus {
  DRAFT
  APPROVED
  SENT
}

// Collection feature - request-scoped evidence intake
enum CollectedItemStatus {
  UNREVIEWED
  APPROVED
  REJECTED
}

// Review workflow status for inbound messages
enum ReviewStatus {
  UNREVIEWED
  NEEDS_FOLLOW_UP
  REVIEWED
}

enum CollectedItemSource {
  EMAIL_REPLY
  MANUAL_UPLOAD
  FORM_SUBMISSION
}

// Board represents a period-based checklist (e.g., "January 2025 Book Close")
// Boards group Jobs for accounting period workflows (Monday.com parity)
enum BoardStatus {
  // New action-oriented statuses
  NOT_STARTED // Work not yet begun
  IN_PROGRESS // Work actively happening
  COMPLETE // All work done
  BLOCKED // Waiting on external dependency
  ARCHIVED // Hidden from active view
  // Legacy statuses (kept for backward compatibility during migration)
  OPEN // @deprecated - use NOT_STARTED
  CLOSED // @deprecated - use COMPLETE
}

// Board cadence - what kind of time period this board represents
// FUTURE: cadence + periodStart/periodEnd enable auto-creation and AI reasoning
enum BoardCadence {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  YEAR_END
  AD_HOC
}

// Subtask status for checklist items within a Job (Monday.com subitem parity)
enum SubtaskStatus {
  NOT_STARTED
  IN_PROGRESS
  STUCK
  DONE
}

model Organization {
  id                   String   @id @default(cuid())
  name                 String
  slug                 String   @unique
  emailDomain          String?
  features             Json? // Account-level feature flags: { expenses: boolean, ap: boolean, ... }
  fiscalYearStartMonth Int      @default(1) // 1 = January, 12 = December
  timezone             String   @default("UTC") // IANA timezone e.g. "America/New_York", "Australia/Sydney"
  aiContext            Json?    // AI context for report insights: { industry, entityType, keyMetrics[], terminology{} }
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  users                   User[]
  entities                Entity[]
  groups                  Group[]
  taskInstances           TaskInstance[]
  taskLineages            TaskLineage[]
  importRecipes           ImportRecipe[]
  connectedEmailAccounts  ConnectedEmailAccount[]
  automationRules         AutomationRule[]
  emailDrafts             EmailDraft[]
  agentSchedules          AgentSchedule[]
  boards                  Board[]
  subtasks                Subtask[]
  attachments             Attachment[]
  emailQueue              EmailQueue[]
  databases               Database[]
  reportDefinitions       ReportDefinition[]
  generatedReports        GeneratedReport[]
  formDefinitions         FormDefinition[]
  formRequests            FormRequest[]
  formAttachments         FormAttachment[]
  reconciliationConfigs   ReconciliationConfig[]
  accountingIntegration   AccountingIntegration?
  notifications           Notification[]

  @@index([slug])
}

model TaskLineage {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  description    String?
  config         Json? // Optional configuration for lineage templates
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization  Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  instances     TaskInstance[]
  importRecipes ImportRecipe[]

  @@index([organizationId])
}

model ImportRecipe {
  id             String   @id @default(cuid())
  organizationId String
  lineageId      String
  name           String
  mapping        Json // CSV Header -> Schema Column mapping
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  lineage      TaskLineage  @relation(fields: [lineageId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([lineageId])
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  passwordHash   String
  name           String?
  role           UserRole @default(MEMBER)
  // Module-level access toggles (JSON): which dashboard modules this user can access
  // { boards: true, inbox: true, requests: false, collection: false, reports: true, forms: true, databases: false, reconciliations: false, contacts: false }
  // null = default access based on role (ADMIN gets all, MEMBER gets boards+inbox+reports+forms)
  moduleAccess   Json?
  signature      String? // User's email signature
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  lastLoginAt    DateTime? // Tracks most recent login time

  // Auth token fields for verification, password reset, and invites
  emailVerified     Boolean   @default(false)
  verificationToken String?   @unique
  tokenExpiresAt    DateTime?

  // Onboarding tracking
  onboardingCompleted Boolean @default(false)
  onboardingDismissed Boolean @default(false)

  organization               Organization               @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  emailDrafts                EmailDraft[]
  ownedTaskInstances         TaskInstance[]             @relation("TaskInstanceOwner")
  taskInstanceCollaborations TaskInstanceCollaborator[]
  taskInstanceComments       TaskInstanceComment[]
  reviewedItems              CollectedItem[]            @relation("CollectedItemReviewer")
  ownedBoards                Board[]                    @relation("BoardOwner")
  createdBoards              Board[]                    @relation("BoardCreator")
  boardCollaborations        BoardCollaborator[]
  ownedSubtasks              Subtask[]                  @relation("SubtaskOwner")
  uploadedAttachments        Attachment[]               @relation("AttachmentUploader")
  reviewedMessages           Message[]                  @relation("MessageReviewer")
  reviewAuditLogs            ReviewAuditLog[]           @relation("ReviewAuditAuthor")
  connectedEmailAccounts     ConnectedEmailAccount[]
  createdDatabases           Database[]                 @relation("DatabaseCreator")
  importedDatabases          Database[]                 @relation("DatabaseImporter")
  createdReportDefinitions   ReportDefinition[]         @relation("ReportDefinitionCreator")
  reportViewerPermissions    GeneratedReportViewer[]
  reportDefinitionViewerPermissions  ReportDefinitionViewer[] @relation("ReportDefinitionViewerUser")
  createdFormDefinitions     FormDefinition[]           @relation("FormDefinitionCreator")
  formRequests               FormRequest[]              @relation("FormRequestRecipient")
  completedReconciliations   ReconciliationRun[]        @relation("ReconciliationCompleter")
  notifications              Notification[]             @relation("NotificationRecipient")
  formDefinitionViewerPermissions       FormDefinitionViewer[]          @relation("FormDefinitionViewerUser")
  reconciliationConfigViewerPermissions ReconciliationConfigViewer[]    @relation("ReconciliationConfigViewerUser")
  databaseViewerPermissions             DatabaseViewer[]                @relation("DatabaseViewerUser")
  createdReconciliationConfigs          ReconciliationConfig[]          @relation("ReconciliationConfigCreator")

  @@index([organizationId])
  @@index([email])
  @@index([verificationToken])
}

// ─── Notifications ──────────────────────────────────────────────────────────

model Notification {
  id             String   @id @default(cuid())
  userId         String   // Recipient user
  organizationId String
  type           String   // "comment", "reply", "status_change", "collaborator_added", "request_sent", "form_response"
  title          String   // Short summary
  body           String?  // Optional longer description
  read           Boolean  @default(false)
  // Links to the source
  taskInstanceId String?  @map("jobId")
  requestId      String?  @map("taskId")
  actorId        String?  // User who triggered the notification (null for system)
  metadata       Json?    // Additional context (e.g. old/new status)
  createdAt      DateTime @default(now())

  user         User          @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)
  organization Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskInstance TaskInstance?  @relation(fields: [taskInstanceId], references: [id], onDelete: SetNull)

  @@index([userId, read])
  @@index([userId, createdAt])
  @@index([organizationId])
}

model Entity {
  id                     String      @id @default(cuid())
  firstName              String
  lastName               String?
  email                  String?
  phone                  String?
  companyName            String? // Company name for accounting reference
  contactType            ContactType @default(UNKNOWN) // @deprecated - use isInternal instead
  contactTypeCustomLabel String? // @deprecated
  isInternal             Boolean     @default(false) // true = internal (employee), false = external (client/vendor)
  mergeRemoteId          String?     // Merge.dev remote_id for contacts synced from accounting software
  addressStreet1         String?     // Primary address from accounting system
  addressStreet2         String?
  addressCity            String?
  addressState           String?
  addressPostalCode      String?
  addressCountry         String?
  organizationId         String
  createdAt              DateTime    @default(now())
  updatedAt              DateTime    @updatedAt

  organization        Organization               @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  groups              EntityGroup[]
  requests            Request[]
  messages            Message[]
  reminderStates      ReminderState[]
  clientTaskInstances TaskInstance[]             @relation("TaskInstanceClient") // Task instances where this entity is the primary client
  taskInstanceLabels  TaskInstanceContactLabel[] // Item-scoped labels applied to this contact
  formRequests        FormRequest[]              @relation("FormRequestEntity") // Form requests sent to this entity

  @@index([organizationId])
  @@index([email])
  @@index([organizationId, email])
  @@index([organizationId, isInternal])
  @@index([organizationId, mergeRemoteId])
}

model Group {
  id             String   @id @default(cuid())
  name           String
  description    String?
  color          String?
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  entities     EntityGroup[]
  schedules    AgentSchedule[]

  @@index([organizationId])
}

model EntityGroup {
  id        String   @id @default(cuid())
  entityId  String
  groupId   String
  createdAt DateTime @default(now())

  entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([entityId, groupId])
  @@index([entityId])
  @@index([groupId])
}

enum ContactType {
  UNKNOWN
  EMPLOYEE
  VENDOR
  CLIENT
  CONTRACTOR
  MANAGEMENT
  CUSTOM
}

// Job represents a persistent work container (e.g., "Tax Planning - Year End 2024")
// Jobs own Tasks (requests), enabling aggregation and status tracking across recipients
// Note: Enum name must match database enum name "JobStatus"
enum JobStatus {
  // New action-oriented statuses
  NOT_STARTED // Work not yet begun
  IN_PROGRESS // Work in progress
  COMPLETE // All work done
  BLOCKED // Blocked by external dependency
  // Legacy statuses (kept for backwards compatibility)
  ACTIVE // @deprecated - use NOT_STARTED or IN_PROGRESS
  WAITING // @deprecated - use IN_PROGRESS
  COMPLETED // @deprecated - use COMPLETE
  ARCHIVED // @deprecated - use COMPLETE
}

// TaskInstance represents a persistent work container for a specific period
// TaskInstances are spawned from TaskLineages and belong to a Board
model TaskInstance {
  id             String    @id @default(cuid())
  organizationId String
  lineageId      String? // Link to parent lineage (template)
  name           String // Human-readable job name (e.g., "Tax Planning - Year End 2024")
  description    String? // Optional detailed description
  clientId       String? // Optional: primary client (Entity) for this job
  ownerId        String // Required: accountable user for this job
  status         JobStatus @default(NOT_STARTED)
  dueDate        DateTime? // Target completion date
  labels         Json? // Flexible tagging/categorization
  boardId        String? // Optional: parent Board for period-based organization
  sortOrder      Int?      @default(0) // Order within board for drag-drop reordering
  notes          String? // User notes for this task
  customFields   Json? // Custom column data for configurable table
  structuredData Json? // Structured data storage
  isSnapshot     Boolean   @default(false) // If true, this instance is an immutable historical record
  
  // Report configuration - any task can have a report linked
  reportDefinitionId     String?
  reportFilterBindings   Json?    // Dynamic filters: { "location": ["Bixby, OK"], "brand": ["CHIPOTLE"] }
  
  // Reconciliation configuration - any task can point to a reusable reconciliation config
  reconciliationConfigId String?
  
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization    Organization               @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  lineage         TaskLineage?               @relation(fields: [lineageId], references: [id], onDelete: SetNull)
  client          Entity?                    @relation("TaskInstanceClient", fields: [clientId], references: [id], onDelete: SetNull)
  owner           User                       @relation("TaskInstanceOwner", fields: [ownerId], references: [id])
  board           Board?                     @relation(fields: [boardId], references: [id], onDelete: SetNull)
  reportDefinition ReportDefinition?         @relation(fields: [reportDefinitionId], references: [id], onDelete: SetNull)
  reconciliationConfig ReconciliationConfig? @relation(fields: [reconciliationConfigId], references: [id], onDelete: SetNull)
  collaborators   TaskInstanceCollaborator[] // Team members who can collaborate on this job
  requests        Request[] // Child tasks (requests) belonging to this job
  emailDrafts     EmailDraft[] // Request-level association
  comments        TaskInstanceComment[] // Internal collaboration comments
  collectedItems  CollectedItem[] // Evidence/attachments collected for this job
  subtasks        Subtask[] // Checklist subitems within this job
  attachments     Attachment[] // Direct file attachments on this job
  generatedReports GeneratedReport[] // Reports generated for this task
  formRequests     FormRequest[] // Form requests sent for this task

  taskInstanceLabels TaskInstanceLabel[] // Item-scoped labels for contacts
  reconciliationRuns ReconciliationRun[] // Reconciliation runs triggered from this task
  notifications      Notification[] // Notifications related to this task

  @@index([organizationId])
  @@index([organizationId, status])
  @@index([clientId])
  @@index([ownerId])
  @@index([organizationId, createdAt])
  @@index([boardId])
  @@index([lineageId])
  @@index([reconciliationConfigId])
  @@map("Job")
}

// TaskInstanceLabel defines labels that can be applied to contacts within a specific TaskInstance
// e.g., "paid", "unpaid", "pending" with metadata schemas like invoice_number, amount
model TaskInstanceLabel {
  id             String   @id @default(cuid())
  taskInstanceId String   @map("jobId")
  organizationId String
  name           String // "unpaid", "received", "pending"
  color          String? // "#ef4444"
  metadataSchema Json     @default("[]") // [{key: "invoice_number", label: "Invoice #", type: "text"}]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  taskInstance  TaskInstance               @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  contactLabels TaskInstanceContactLabel[]

  @@unique([taskInstanceId, name])
  @@index([taskInstanceId])
  @@index([organizationId])
  @@map("JobLabel")
}

// TaskInstanceContactLabel applies a label to a contact within a TaskInstance's context
// Stores the metadata values for that contact-label pair
model TaskInstanceContactLabel {
  id                  String   @id @default(cuid())
  taskInstanceLabelId String   @map("jobLabelId")
  entityId            String
  metadata            Json     @default("{}") // {invoice_number: "INV-001", amount: "500.00"}
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  taskInstanceLabel TaskInstanceLabel @relation(fields: [taskInstanceLabelId], references: [id], onDelete: Cascade)
  entity            Entity            @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([taskInstanceLabelId, entityId])
  @@index([taskInstanceLabelId])
  @@index([entityId])
  @@map("JobContactLabel")
}

// TaskInstanceCollaborator join table for team collaboration on TaskInstances
// This replaces a JSON array for better querying, indexing, and auditing
model TaskInstanceCollaborator {
  id             String   @id @default(cuid())
  taskInstanceId String   @map("jobId")
  userId         String
  role           String   @default("collaborator") // Future: "viewer"
  addedAt        DateTime @default(now())
  addedBy        String // User.id who added this collaborator

  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskInstanceId, userId])
  @@index([userId]) // Fast "My Tasks" query
  @@index([taskInstanceId])
  @@map("JobCollaborator")
}

// TaskInstanceComment for internal team collaboration
model TaskInstanceComment {
  id             String   @id @default(cuid())
  taskInstanceId String   @map("jobId")
  authorId       String
  content        String
  mentions       Json? // Array of mentioned user IDs
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  author       User         @relation(fields: [authorId], references: [id])

  @@index([taskInstanceId])
  @@index([authorId])
  @@map("JobComment")
}

model Request {
  id                       String        @id @default(cuid())
  taskInstanceId           String?       @map("jobId") // Optional: parent TaskInstance for request-level association
  entityId                 String? // Optional: contact may be deleted but request history preserved
  campaignName             String?
  campaignType             CampaignType?
  requestType              String?       // "standard" | "data" | "form" - source of the request
  status                   TaskStatus    @default(AWAITING_RESPONSE)
  threadId                 String        @unique
  replyToEmail             String?
  replyToPhone             String?
  aiReasoning              Json? // Store AI reasoning as JSON
  aiSummary                String? // 2-3 sentence task summary
  aiSummaryConfidence      String? // High, Medium, Low
  aiSummaryLastMessageId   String? // Track which message summary is based on (for idempotency)
  aiVerified               Boolean?
  verifiedAt               DateTime?
  documentUrl              String?
  documentKey              String?
  hasAttachments           Boolean       @default(false)
  completionPercentage     Int? // LLM-determined completion percentage (0-100) based on reply intent
  readStatus               String? // unread | read | replied
  riskLevel                String? // high | medium | low | unknown
  riskReason               String? // Short explanation of risk level
  manualRiskOverride       String? // high | medium | low | null (if manually set)
  overrideReason           String? // Reason for manual override
  lastActivityAt           DateTime? // Last activity timestamp (opened, replied, etc.)
  deadlineDate             DateTime? // Deadline/due date for the request (set during compose)
  // Reminder configuration fields (additive, nullable for backward compatibility)
  remindersEnabled         Boolean       @default(false)
  remindersStartDelayHours Int? // Hours/days before first reminder (converted to hours)
  remindersFrequencyHours  Int? // Hours/days between reminders (converted to hours)
  remindersMaxCount        Int? // Maximum reminders (1-5)
  remindersApproved        Boolean       @default(false) // Whether user approved the sequence

  // Period-aware scheduling (collapsed into JSON for minimal schema footprint)
  // scheduleConfig: { mode: "ad_hoc"|"period_aware", anchor?: "period_start"|"period_end",
  //                   offsetDays?: number, weekendRule?: "previous"|"next", sendTime?: "HH:mm" }
  scheduleConfig  Json? // Scheduling recipe
  scheduledSendAt DateTime? // Computed absolute send datetime (for display/audit)

  // Draft request fields (copy-on-write pattern for recurring request drafts)
  isDraft              Boolean @default(false) // True = draft copied from prior period, not yet sent
  draftSourceRequestId String? // Link to source request from prior period (for content + audit)
  draftEditedSubject   String? // Only populated if user edits the draft subject
  draftEditedBody      String? @db.Text // Only populated if user edits the draft body
  draftEditedHtmlBody  String? @db.Text // Only populated if user edits the draft HTML body

  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  taskInstance      TaskInstance?      @relation(fields: [taskInstanceId], references: [id], onDelete: SetNull)
  entity            Entity?            @relation(fields: [entityId], references: [id], onDelete: SetNull)
  messages          Message[]
  reminderStates    ReminderState[]
  collectedItems    CollectedItem[] // Evidence/attachments collected for this request
  aiRecommendations AIRecommendation[] // AI recommendations for feedback loop

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([entityId])
  @@index([status])
  @@index([threadId])
  @@index([organizationId, status])
  @@index([organizationId, campaignName])
  @@index([organizationId, campaignType])
  @@index([organizationId, isDraft]) // For filtering draft vs active requests
  @@index([draftSourceRequestId]) // For looking up source request content
  @@map("Task")
}

model Message {
  id               String           @id @default(cuid())
  requestId        String           @map("taskId")
  entityId         String? // Optional: contact may be deleted but message history preserved
  direction        MessageDirection
  channel          MessageChannel   @default(EMAIL)
  subject          String?
  body             String?
  htmlBody         String?
  fromAddress      String
  toAddress        String
  providerId       String? // Gmail message ID or SMTP message ID
  providerData     Json? // Store full provider payload
  messageIdHeader  String? // Message-ID header from email (indexed for efficient reply matching)
  threadId         String? // Gmail thread ID (indexed for efficient reply matching)
  attachments      Json? // Store attachment metadata as JSON
  trackingToken    String?          @unique // Unique token for tracking pixel URL
  openedAt         DateTime? // First time email was opened
  openedCount      Int              @default(0) // Number of times opened
  lastOpenedAt     DateTime? // Most recent open time
  aiClassification String? // DATA, QUESTION, COMPLAINT, ACKNOWLEDGMENT, OTHER
  aiReasoning      String? // Brief explanation of classification
  isAutoReply      Boolean          @default(false) // True if this is an OOO, bounce, or auto-reply
  createdAt        DateTime         @default(now())

  // Review workflow fields
  reviewStatus ReviewStatus @default(UNREVIEWED)
  reviewedAt   DateTime?
  reviewedById String?
  reviewNotes  String?

  entity            Entity?            @relation(fields: [entityId], references: [id], onDelete: SetNull)
  request           Request            @relation(fields: [requestId], references: [id], onDelete: Cascade)
  collectedItems    CollectedItem[] // Evidence/attachments extracted from this message
  reviewedBy        User?              @relation("MessageReviewer", fields: [reviewedById], references: [id])
  auditLogs         ReviewAuditLog[]
  aiRecommendations AIRecommendation[] // AI recommendations for feedback loop

  @@index([requestId])
  @@index([entityId])
  @@index([providerId])
  @@index([requestId, createdAt])
  @@index([trackingToken])
  @@index([messageIdHeader])
  @@index([threadId])
  @@index([isAutoReply])
  @@index([reviewStatus])
}

model AgentSchedule {
  id             String        @id @default(cuid())
  name           String
  cronExpression String
  timezone       String        @default("UTC")
  organizationId String
  groupId        String?
  campaignName   String?
  campaignType   CampaignType?
  emailSubject   String
  emailBody      String
  htmlBody       String?
  lastRunAt      DateTime?
  nextRunAt      DateTime?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  group        Group?       @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([groupId])
  @@index([isActive, nextRunAt])
}

model ConnectedEmailAccount {
  id             String        @id @default(cuid())
  organizationId String
  userId         String? // User who connected this account (null = legacy/shared)
  email          String
  provider       EmailProvider
  accessToken    String? // Encrypted
  refreshToken   String? // Encrypted
  tokenExpiresAt DateTime?
  syncCursor     Json?
  lastSyncAt     DateTime?
  smtpHost       String?
  smtpPort       Int?
  smtpUser       String?
  smtpPassword   String? // Encrypted
  smtpSecure     Boolean       @default(true)
  isPrimary      Boolean       @default(false)
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User?        @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([userId])
  @@index([email])
  @@index([organizationId, isPrimary])
  @@index([organizationId, userId])
}

model AutomationRule {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  trigger        String // Event that triggers the rule
  conditions     Json // Store conditions as JSON
  actions        Json // Store actions as JSON
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([isActive])
}

model EmailDraft {
  id                    String           @id @default(cuid())
  organizationId        String
  userId                String
  taskInstanceId        String?          @map("jobId") // Optional: parent TaskInstance
  prompt                String
  generatedSubject      String?
  generatedBody         String?
  generatedHtmlBody     String?
  // Personalization fields
  subjectTemplate       String? // Template with {{Tag Name}} placeholders
  bodyTemplate          String? // Template with {{Tag Name}} placeholders
  htmlBodyTemplate      String? // HTML template with {{Tag Name}} placeholders
  availableTags         Json? // Array of available tag names
  personalizationMode   String? // "none" | "contact" | "csv"
  blockOnMissingValues  Boolean          @default(true)
  deadlineDate          DateTime? // Deadline date for the request
  // Legacy fields (keeping for backwards compatibility)
  suggestedRecipients   Json? // Store suggested entity/group IDs as JSON
  suggestedCampaignName String?
  suggestedCampaignType CampaignType?
  status                EmailDraftStatus @default(DRAFT)
  idempotencyKey        String?          @unique
  aiGenerationStatus    String? // "processing", "complete", "failed", "timeout"
  sentAt                DateTime? // Timestamp when draft was sent (for idempotency)
  sendAttemptId         String? // Unique ID for send attempt tracking
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt

  organization        Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  taskInstance        TaskInstance?         @relation(fields: [taskInstanceId], references: [id], onDelete: SetNull)
  personalizationData PersonalizationData[]

  @@index([organizationId])
  @@index([userId])
  @@index([taskInstanceId])
  @@index([status])
  @@index([idempotencyKey])
}

model PersonalizationData {
  id             String   @id @default(cuid())
  emailDraftId   String
  recipientEmail String
  contactId      String? // Optional reference to Entity
  dataJson       Json // Key/value map from CSV + contact fields
  renderSubject  String? // Rendered subject for this recipient
  renderBody     String? // Rendered body for this recipient
  renderHtmlBody String? // Rendered HTML body for this recipient
  renderStatus   String? // "ok" | "missing" | "failed"
  renderErrors   Json? // Array of error messages if renderStatus is "failed" or "missing"
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  emailDraft EmailDraft @relation(fields: [emailDraftId], references: [id], onDelete: Cascade)

  @@unique([emailDraftId, recipientEmail])
  @@index([emailDraftId])
  @@index([recipientEmail])
}

model ReminderState {
  id               String    @id @default(cuid())
  requestId        String    @map("taskId") // Link to Request (the threaded communication)
  entityId         String? // Recipient entity (optional: contact may be deleted)
  reminderNumber   Int // Which reminder this is (1, 2, 3, etc.)
  sentCount        Int       @default(0) // How many reminders sent (incremented when sent)
  nextSendAt       DateTime? // When next reminder should be sent (null if stopped or max reached)
  lastSentAt       DateTime? // When last reminder was sent
  stoppedReason    String? // "replied" | "max_reached" | "manual_stop" | null
  scheduledEventId String?   @unique // Inngest event ID for idempotency (prevents duplicate sends)
  organizationId   String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)
  entity  Entity? @relation(fields: [entityId], references: [id], onDelete: SetNull)

  @@unique([requestId, entityId]) // One state per request+entity
  @@index([requestId])
  @@index([entityId])
  @@index([organizationId, nextSendAt]) // For querying requests that need reminders
  @@index([scheduledEventId]) // For idempotency checks
}

// CollectedItem represents evidence/attachments received in response to requests
// This is the core model for the Collection feature - request-scoped evidence intake
model CollectedItem {
  id             String  @id @default(cuid())
  organizationId String
  taskInstanceId String  @map("jobId") // Parent task instance (required)
  requestId      String? @map("taskId") // Optional: specific request this came from
  messageId      String? // Optional: source message if from email

  // File metadata
  filename String
  fileKey  String // Storage key (blob or local)
  fileUrl  String? // Cached URL for quick access
  fileSize Int? // Bytes
  mimeType String?

  // Source tracking
  source          CollectedItemSource
  submittedBy     String? // Email address of submitter
  submittedByName String? // Name if available
  receivedAt      DateTime // When the item was received

  // Approval workflow
  status          CollectedItemStatus @default(UNREVIEWED)
  reviewedBy      String? // User ID who reviewed
  reviewedAt      DateTime?
  rejectionReason String?

  // Metadata
  notes    String? // Internal notes
  metadata Json? // Extensible metadata

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  request      Request?     @relation(fields: [requestId], references: [id], onDelete: SetNull)
  message      Message?     @relation(fields: [messageId], references: [id], onDelete: SetNull)
  reviewer     User?        @relation("CollectedItemReviewer", fields: [reviewedBy], references: [id])

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([requestId])
  @@index([messageId])
  @@index([status])
  @@index([taskInstanceId, status])
  @@index([organizationId, taskInstanceId])
}

// Board represents a period-based checklist (e.g., "January 2025 Book Close")
// Boards group Jobs for accounting period workflows (Monday.com parity)
model Board {
  id             String      @id @default(cuid())
  organizationId String
  name           String // "January 2025 Book Close", "Year-End Close 2024"
  description    String?
  status         BoardStatus @default(NOT_STARTED)

  // Ownership (nullable during migration, will become required after data backfill)
  ownerId String? // Accountable user for this board

  // Time metadata - enables filtering, sorting, and future auto-creation
  cadence     BoardCadence? // Type of time period (Monthly, Weekly, etc.)
  periodStart DateTime? // Start of the time period
  periodEnd   DateTime? // End of the time period

  // Automation settings (UI config, automation logic not yet implemented)
  automationEnabled Boolean @default(false) // Auto-create next period's board
  skipWeekends      Boolean @default(true) // For DAILY cadence: skip weekends

  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  organization     Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  owner            User?               @relation("BoardOwner", fields: [ownerId], references: [id])
  createdBy        User                @relation("BoardCreator", fields: [createdById], references: [id])
  collaborators    BoardCollaborator[]
  taskInstances    TaskInstance[]
  generatedReports GeneratedReport[]   // Reports generated for this period

  @@index([organizationId])
  @@index([organizationId, status])
  @@index([ownerId])
}

// BoardCollaborator join table for team collaboration on Boards
model BoardCollaborator {
  id      String   @id @default(cuid())
  boardId String
  userId  String
  role    String   @default("collaborator") // Future: "viewer"
  addedAt DateTime @default(now())
  addedBy String // User.id who added this collaborator

  board Board @relation(fields: [boardId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([boardId, userId])
  @@index([userId])
  @@index([boardId])
}

// Subtask represents a checklist item within a Job (Monday.com subitem parity)
// Subtasks have their own owner, status, due date, and attachments
model Subtask {
  id             String        @id @default(cuid())
  organizationId String
  taskInstanceId String        @map("jobId")
  title          String
  description    String?
  ownerId        String? // Nullable - Monday allows unassigned subitems
  status         SubtaskStatus @default(NOT_STARTED)
  dueDate        DateTime?
  sortOrder      Int           @default(0) // Order within task for drag-drop reordering
  completedAt    DateTime? // Timestamp when marked as DONE
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  owner        User?        @relation("SubtaskOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  attachments  Attachment[]

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([ownerId])
  @@index([taskInstanceId, sortOrder])
}

// Attachment represents a direct file upload on a TaskInstance or Subtask
// Distinct from CollectedItem which is for inbound email attachments
model Attachment {
  id             String   @id @default(cuid())
  organizationId String
  taskInstanceId String?  @map("jobId") // One of taskInstanceId or subtaskId must be set
  subtaskId      String?
  filename       String
  fileKey        String // Storage key
  fileUrl        String? // Cached URL
  fileSize       Int? // Bytes
  mimeType       String?
  uploadedById   String
  createdAt      DateTime @default(now())

  organization Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskInstance TaskInstance? @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  subtask      Subtask?      @relation(fields: [subtaskId], references: [id], onDelete: Cascade)
  uploadedBy   User          @relation("AttachmentUploader", fields: [uploadedById], references: [id])

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([subtaskId])
}

// EmailSendAudit provides a persistent audit trail for all email sends
// Critical for debugging, compliance, and customer support
enum EmailSendResult {
  SUCCESS
  FAILED
  BLOCKED
  RATE_LIMITED
  QUEUED // Email was queued for later due to rate limiting
}

// EmailQueue stores emails that were rate-limited and need to be sent later
// A scheduled job processes this queue when rate limits allow
enum EmailQueueStatus {
  PENDING // Waiting to be sent
  PROCESSING // Currently being processed
  SENT // Successfully sent
  FAILED // Failed after max retries
  CANCELLED // Manually cancelled
}

model EmailQueue {
  id             String  @id @default(cuid())
  organizationId String
  userId         String? // User who initiated the send
  taskInstanceId String? @map("jobId") // Related task instance
  requestId      String? @map("taskId") // Related request (if updating existing)

  // Email details (stored for retry)
  toEmail   String
  subject   String
  body      String  @db.Text
  htmlBody  String? @db.Text
  accountId String? // Email account to send from

  // Queue management
  status        EmailQueueStatus @default(PENDING)
  priority      Int              @default(0) // Higher = more urgent
  attempts      Int              @default(0)
  maxAttempts   Int              @default(3)
  lastAttemptAt DateTime?
  nextAttemptAt DateTime // When to try sending next

  // Error tracking
  lastError String?

  // Metadata for the original send request
  metadata Json? // Original send parameters (deadlineDate, remindersConfig, etc.)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([status, nextAttemptAt]) // For queue processing
  @@index([toEmail])
  @@index([createdAt])
}

// ReviewAuditLog provides audit trail for review actions
model ReviewAuditLog {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  action    String // "marked_reviewed" | "marked_needs_follow_up" | "reply_sent" | "follow_up_created"
  metadata  Json?
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation("ReviewAuditAuthor", fields: [userId], references: [id])

  @@index([messageId])
  @@index([userId])
  @@index([createdAt])
}

model EmailSendAudit {
  id             String  @id @default(cuid())
  organizationId String
  userId         String? // User who initiated the send (null for system sends)
  taskInstanceId String? @map("jobId") // Related task instance if applicable
  requestId      String? @map("taskId") // Related request if applicable
  emailDraftId   String? // Related email draft if applicable

  // Send details
  fromEmail      String
  toEmail        String // Single recipient (one row per recipient for bulk)
  subject        String
  recipientCount Int    @default(1) // For bulk sends, total recipients in batch

  // Result tracking
  result       EmailSendResult
  errorMessage String? // Error details if failed
  errorCode    String? // Provider error code if available

  // Provider details
  provider   EmailProvider? // GMAIL, MICROSOFT, GENERIC_SMTP
  providerId String? // Message ID from provider

  // Metadata
  ipAddress String? // Request IP for audit
  userAgent String? // Request user agent
  metadata  Json? // Additional context (e.g., personalization mode, reminder number)

  createdAt DateTime @default(now())

  @@index([organizationId])
  @@index([organizationId, createdAt])
  @@index([userId])
  @@index([taskInstanceId])
  @@index([requestId])
  @@index([toEmail])
  @@index([result])
  @@index([createdAt])
}

// Column configuration for Monday.com-style configurable task tables
model JobColumnConfig {
  id             String   @id @default(cuid())
  organizationId String   @unique // One config per organization
  boardId        String? // Optional: board-specific config (null = global default)
  columns        Json // Array of column definitions: { id, type, label, width, visible, order }
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([organizationId, boardId])
  @@index([organizationId])
}

// AI recommendation storage for feedback loop
// Persists AI analysis results and links them to human decisions
model AIRecommendation {
  id             String @id @default(cuid())
  organizationId String
  messageId      String
  requestId      String @map("taskId")

  // Denormalized for metrics queries
  campaignType CampaignType?

  // AI recommendation
  recommendedAction String // "REVIEWED" | "NEEDS_FOLLOW_UP" (matches ReviewStatus)
  reasoning         String // Short explanation
  summaryBullets    Json? // Array of summary points
  findings          Json? // Array of findings

  // Model tracking
  model         String @default("gpt-4o-mini")
  promptVersion String @default("v1")

  // Draft reply (generated with memory, persisted for idempotency)
  draftReply         String? // Pre-filled draft reply text
  draftPromptVersion String? // Track draft prompt version separately

  // Human reconciliation (filled when user acts)
  humanAction  String? // Actual ReviewStatus chosen
  agreedWithAI Boolean? // Computed: recommendedAction == humanAction
  humanActedAt DateTime?

  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([organizationId, createdAt])
  @@index([messageId])
  @@index([organizationId, campaignType, agreedWithAI])
}

// Database represents a structured data store with schema and rows
// This is the core model for the Databases feature - standalone structured data management
model Database {
  id              String   @id @default(cuid())
  name            String
  description     String?
  organizationId  String

  // Schema definition (JSON) - DatabaseSchema type
  // { columns: DatabaseSchemaColumn[], version: number }
  schema          Json
  identifierKeys  Json     // String[] - Column keys that together form the unique row identifier (composite key)

  // Current data (JSON array of rows) - DatabaseRow[]
  rows            Json     @default("[]")
  rowCount        Int      @default(0)

  // Integration source tracking
  sourceType      String?  // null = manual, "merge_accounts", "merge_invoices", "merge_gl", etc.
  isReadOnly      Boolean  @default(false) // true for integration-synced databases
  syncFilter      Json?    // Column-value filters for accounting source: [{ column: "status", value: "UNPAID" }]
  lastSyncAsOfDate String? // Last "as of" date used for sync (YYYY-MM-DD)
  syncStatus      String?  // null | "syncing" | "error" | "success"
  lastSyncError   String?  // Error message from last sync attempt

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdById     String
  lastImportedAt  DateTime?
  lastImportedById String?

  organization       Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdBy          User               @relation("DatabaseCreator", fields: [createdById], references: [id])
  lastImportedBy     User?              @relation("DatabaseImporter", fields: [lastImportedById], references: [id])
  reportDefinitions  ReportDefinition[]
  formDefinitions    FormDefinition[]
  viewers            DatabaseViewer[]

  @@index([organizationId])
  @@index([organizationId, name])
  @@index([organizationId, sourceType])
}

// FormDefinition represents a form template for collecting structured data from users
// Forms are linked to a Database where responses are stored as rows
model FormDefinition {
  id              String   @id @default(cuid())
  name            String
  description     String?
  organizationId  String
  
  // Form field definitions (JSON array)
  // Array of: { key, label, type, required, helpText?, defaultValue?, options?, validation?, order }
  fields          Json     @default("[]")
  
  // Form settings
  // { allowEdit: boolean, enforceDeadline: boolean }
  settings        Json     @default("{}")
  
  // Target database for storing responses
  databaseId      String?
  // Mapping from form field keys to database column keys
  // { formFieldKey: databaseColumnKey }
  columnMapping   Json     @default("{}")
  
  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdById     String
  
  organization    Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  database        Database?     @relation(fields: [databaseId], references: [id], onDelete: SetNull)
  createdBy       User          @relation("FormDefinitionCreator", fields: [createdById], references: [id])
  formRequests    FormRequest[]
  viewers         FormDefinitionViewer[]

  @@index([organizationId])
  @@index([databaseId])
}

// FormRequest represents a form sent to a specific user for completion
// Each request tracks submission status and links to the database row created/updated
model FormRequest {
  id                String    @id @default(cuid())
  organizationId    String
  taskInstanceId    String
  formDefinitionId  String
  
  // Recipient can be either an internal user OR an external entity (stakeholder)
  recipientUserId   String?   // Internal user (has login account)
  recipientEntityId String?   // External stakeholder (no login account)
  
  // Access token for external stakeholders to access form without login
  accessToken       String?   @unique
  
  // Status: PENDING (awaiting response), SUBMITTED (completed), EXPIRED (past deadline)
  status            String    @default("PENDING")
  submittedAt       DateTime?
  
  // Response data (JSON object of form field values)
  responseData      Json?
  // Index into database.rows array for the row created for this request
  databaseRowIndex  Int?
  
  // Deadline and reminders
  deadlineDate      DateTime?
  remindersEnabled  Boolean   @default(false)
  remindersSent     Int       @default(0)
  remindersMaxCount Int       @default(3)
  reminderFrequencyHours Int  @default(72) // 3 days default
  nextReminderAt    DateTime?
  
  // Metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  organization      Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskInstance      TaskInstance   @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  formDefinition    FormDefinition @relation(fields: [formDefinitionId], references: [id], onDelete: Cascade)
  recipientUser     User?          @relation("FormRequestRecipient", fields: [recipientUserId], references: [id])
  recipientEntity   Entity?        @relation("FormRequestEntity", fields: [recipientEntityId], references: [id])
  attachments       FormAttachment[]
  
  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([recipientUserId])
  @@index([recipientEntityId])
  @@index([status])
  @@index([nextReminderAt])
  @@index([accessToken])
}

// FormAttachment stores files uploaded via form submissions
// Files are stored in Vercel Blob, with metadata tracked here
model FormAttachment {
  id              String       @id @default(cuid())
  organizationId  String
  formRequestId   String
  fieldKey        String       // Which form field this belongs to
  
  filename        String       // Original filename
  url             String       // Vercel Blob URL
  mimeType        String       // e.g., "application/pdf"
  sizeBytes       Int
  
  uploadedAt      DateTime     @default(now())
  
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  formRequest     FormRequest  @relation(fields: [formRequestId], references: [id], onDelete: Cascade)
  
  @@index([organizationId])
  @@index([formRequestId])
  @@index([formRequestId, fieldKey])
}

// ReportDefinition represents an Excel-like report template
// Users define columns (source + formula) and formula rows (aggregations)
// The report renders data from a linked Database
model ReportDefinition {
  id              String   @id @default(cuid())
  name            String
  description     String?
  organizationId  String
  databaseId      String
  
  // Period configuration
  cadence         String   // "daily" | "monthly" | "quarterly" | "annual"
  dateColumnKey   String   // Database column key containing date data for period filtering
  
  // Layout mode: "standard" (rows=db rows, cols=selected) or "pivot" (cols=pivot values, rows=metrics)
  layout          String   @default("standard")
  
  // === Standard layout fields ===
  // Column configuration (selected database columns + formula columns)
  // Array of: { key, label, type: "source"|"formula", sourceColumnKey?, expression?, dataType, order }
  columns         Json     @default("[]")
  
  // Formula rows (aggregation rows at bottom, like Excel SUM rows)
  // Array of: { key, label, columnFormulas: { [colKey]: "SUM"|"AVG"|expression }, order }
  formulaRows     Json     @default("[]")
  
  // === Pivot / Accounting layout fields ===
  // Database column whose unique values become column headers (e.g., project_name, as_of_date)
  pivotColumnKey  String?

  // === Accounting layout fields ===
  // Column identifying each row (e.g., account_name)
  rowColumnKey     String?
  // Column providing cell values (e.g., current_balance)
  valueColumnKey   String?
  
  // Metric rows for pivot layout
  // Array of: { key, label, type: "source"|"formula", sourceColumnKey?, expression?, format, order }
  metricRows      Json     @default("[]")
  
  // Formula columns for pivot layout - computed columns that aggregate across pivot columns
  // Array of: { key, label, expression, order }
  pivotFormulaColumns Json @default("[]")
  
  // Variance analysis configuration
  compareMode     String   @default("none")  // "none" | "mom" | "yoy"
  
  // Filter configuration - which database columns to expose as filters
  // Array of column keys: ["location", "brand", "pm"]
  // Auto-derived from filterBindings keys when filterBindings is set
  filterColumnKeys Json    @default("[]")

  // Baked-in filter values for this report definition
  // Record<string, string[]> e.g. { "location": ["Bixby, OK"], "pm": ["Caleb"] }
  // When set, these filters are enforced server-side for all viewers
  filterBindings   Json?
  
  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdById     String
  
  organization     Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  database         Database         @relation(fields: [databaseId], references: [id], onDelete: Cascade)
  createdBy        User             @relation("ReportDefinitionCreator", fields: [createdById], references: [id])
  taskInstances    TaskInstance[]   // Tasks that use this report template
  generatedReports GeneratedReport[] // Reports generated from this template
  viewers          ReportDefinitionViewer[] // Users with viewer access to reports from this builder

  @@index([organizationId])
  @@index([databaseId])
}

// GeneratedReport stores the output of a report for a specific period
// Created automatically when a board with REPORTS tasks completes, or manually by user
model GeneratedReport {
  id                 String   @id @default(cuid())
  organizationId     String
  reportDefinitionId String
  taskInstanceId     String?  // Source task that triggered generation (null for manual reports)
  boardId            String?  // Board period that was completed (null for manual reports)
  periodKey          String   // e.g., "2026-01" for monthly, "2026-Q1" for quarterly
  source             String   @default("task") // "task" or "manual"
  
  // Snapshot of report output at generation time
  data               Json     // { columns, rows, formulaRows, metrics, etc. }
  
  // Metadata
  generatedAt        DateTime @default(now())
  generatedBy        String   // "system" or userId
  
  organization       Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  reportDefinition   ReportDefinition @relation(fields: [reportDefinitionId], references: [id], onDelete: Cascade)
  taskInstance       TaskInstance?    @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  board              Board?           @relation(fields: [boardId], references: [id], onDelete: Cascade)
  viewers            GeneratedReportViewer[]
  
  @@index([organizationId, periodKey])
  @@index([reportDefinitionId])
  @@index([boardId])
  @@index([taskInstanceId])
}

// GeneratedReportViewer - join table for report viewer permissions
// Admins can see all reports; non-admins can only see reports they're viewers of
model GeneratedReportViewer {
  id                String   @id @default(cuid())
  generatedReportId String
  userId            String
  addedAt           DateTime @default(now())
  addedBy           String
  
  generatedReport GeneratedReport @relation(fields: [generatedReportId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([generatedReportId, userId])
  @@index([userId])
}

// ReportDefinitionViewer - join table for report builder viewer permissions
// Admins can see all reports; non-admins must be explicit viewers of the report builder
model ReportDefinitionViewer {
  id                   String   @id @default(cuid())
  reportDefinitionId   String
  userId               String
  addedAt              DateTime @default(now())
  addedBy              String

  reportDefinition     ReportDefinition @relation(fields: [reportDefinitionId], references: [id], onDelete: Cascade)
  user                 User             @relation("ReportDefinitionViewerUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reportDefinitionId, userId])
  @@index([userId])
}

// FormDefinitionViewer - join table for form builder viewer permissions
model FormDefinitionViewer {
  id                 String   @id @default(cuid())
  formDefinitionId   String
  userId             String
  addedAt            DateTime @default(now())
  addedBy            String

  formDefinition     FormDefinition @relation(fields: [formDefinitionId], references: [id], onDelete: Cascade)
  user               User           @relation("FormDefinitionViewerUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([formDefinitionId, userId])
  @@index([userId])
}

// ReconciliationConfigViewer - join table for reconciliation config viewer permissions
model ReconciliationConfigViewer {
  id                       String   @id @default(cuid())
  reconciliationConfigId   String
  userId                   String
  addedAt                  DateTime @default(now())
  addedBy                  String

  reconciliationConfig     ReconciliationConfig @relation(fields: [reconciliationConfigId], references: [id], onDelete: Cascade)
  user                     User                 @relation("ReconciliationConfigViewerUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reconciliationConfigId, userId])
  @@index([userId])
}

// DatabaseViewer - join table for database viewer permissions
model DatabaseViewer {
  id          String   @id @default(cuid())
  databaseId  String
  userId      String
  addedAt     DateTime @default(now())
  addedBy     String

  database    Database @relation(fields: [databaseId], references: [id], onDelete: Cascade)
  user        User     @relation("DatabaseViewerUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([databaseId, userId])
  @@index([userId])
}

// AppError - Frontend error tracking for admin dashboard
model AppError {
  id             String   @id @default(cuid())
  organizationId String?
  userId         String?
  errorMessage   String
  errorStack     String?  @db.Text
  componentName  String?
  pageUrl        String?
  userAgent      String?
  metadata       Json?
  severity       String   @default("error") // "error" | "warning" | "fatal"
  resolved       Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([organizationId])
  @@index([createdAt])
  @@index([severity])
}

// ── Reconciliation Feature ──────────────────────────────────────────────

enum ReconciliationRunStatus {
  PENDING      // Awaiting file uploads
  PROCESSING   // Matching engine running
  REVIEW       // Matches generated, awaiting human review
  COMPLETE     // Signed off by user
}

// Reusable reconciliation configuration (like ReportDefinition)
// Created independently, then linked to tasks via TaskInstance.reconciliationConfigId
model ReconciliationConfig {
  id             String   @id @default(cuid())
  organizationId String

  name           String   // "Chase Checking Bank Rec"

  // Source definitions (JSON)
  // { label: string, columns: { key: string, label: string, type: "date"|"amount"|"text"|"reference" }[] }
  sourceAConfig  Json
  sourceBConfig  Json

  // Matching rules (JSON)
  // { amountMatch: "exact"|"tolerance", amountTolerance?: number, dateWindowDays: number, fuzzyDescription: boolean }
  matchingRules  Json

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  createdById    String?

  organization   Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdBy      User?           @relation("ReconciliationConfigCreator", fields: [createdById], references: [id])
  taskInstances  TaskInstance[]   // Tasks that use this config
  runs           ReconciliationRun[]
  viewers        ReconciliationConfigViewer[]

  @@index([organizationId])
}

// One run per period execution (upload two files + matching results)
model ReconciliationRun {
  id              String   @id @default(cuid())
  organizationId  String
  configId        String
  boardId         String?  // Optional: which board/period this run belongs to
  taskInstanceId  String?  // Which task triggered this run

  status          ReconciliationRunStatus @default(PENDING)

  // Uploaded source files
  sourceAFileKey  String?
  sourceAFileName String?
  sourceBFileKey  String?
  sourceBFileName String?

  // Parsed data (JSON arrays of row objects)
  sourceARows     Json?
  sourceBRows     Json?

  // Match results (JSON)
  // { matched: { sourceAIdx, sourceBIdx, confidence, method, reasoning? }[], unmatchedA: number[], unmatchedB: number[] }
  matchResults    Json?

  // Exception classifications (JSON)
  // { [index]: { category, reason, resolution?, resolvedBy?, notes? } }
  exceptions      Json?

  // Summary stats
  totalSourceA    Int      @default(0)
  totalSourceB    Int      @default(0)
  matchedCount    Int      @default(0)
  exceptionCount  Int      @default(0)
  variance        Float    @default(0)  // Dollar variance

  completedAt     DateTime?
  completedBy     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  config          ReconciliationConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  taskInstance    TaskInstance?        @relation(fields: [taskInstanceId], references: [id], onDelete: SetNull)
  completedByUser User?               @relation("ReconciliationCompleter", fields: [completedBy], references: [id])

  @@index([organizationId])
  @@index([configId])
  @@index([organizationId, status])
  @@index([boardId])
  @@index([completedBy])
  @@index([taskInstanceId])
}

// Accounting software integration via Merge.dev
// Stores connection details and sync state per organization
model AccountingIntegration {
  id                String   @id @default(cuid())
  organizationId    String   @unique // One integration per org

  // Merge.dev connection
  accountToken      String   // Encrypted - Merge account_token
  integrationName   String?  // e.g. "Xero", "QuickBooks Online"
  integrationSlug   String?  // e.g. "xero", "quickbooks-online"
  endUserEmail      String?  // Email of user who connected

  // Connection state
  isActive          Boolean  @default(true)
  connectedAt       DateTime @default(now())
  disconnectedAt    DateTime?

  // Sync configuration (JSON) - which models to sync + interval
  // { contacts: true, invoices: true, accounts: true, journalEntries: true,
  //   payments: true, glTransactions: true, syncIntervalMinutes: 60 }
  syncConfig        Json     @default("{}")

  // Per-model sync state (JSON)
  // { contacts: { lastSyncAt, status, error, rowCount },
  //   invoices: { lastSyncAt, status, error, rowCount }, ... }
  syncState         Json     @default("{}")

  // Global sync state
  lastSyncAt        DateTime?
  lastSyncError     String?
  syncStatus        String   @default("idle") // "idle" | "syncing" | "error"

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  organization      Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([isActive])
}

