// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  // "native" = your local machine (Mac/Windows/Linux)
  // "debian-openssl-3.0.x" = Cloud Run production (node:18-slim is Debian-based)
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  MEMBER
  VIEWER
}

enum TaskStatus {
  AWAITING_RESPONSE
  IN_PROGRESS
  REPLIED
  HAS_ATTACHMENTS
  VERIFYING
  FULFILLED
  REJECTED
  FLAGGED
  MANUAL_REVIEW
  ON_HOLD
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageChannel {
  EMAIL
  SMS
}

enum EmailProvider {
  GMAIL
  MICROSOFT
  GENERIC_SMTP
}

enum CampaignType {
  W9
  COI
  EXPENSE
  TIMESHEET
  INVOICE
  RECEIPT
  CUSTOM
}

enum EmailDraftStatus {
  DRAFT
  APPROVED
  SENT
}

// Collection feature - request-scoped evidence intake
enum CollectedItemStatus {
  UNREVIEWED
  APPROVED
  REJECTED
}

enum CollectedItemSource {
  EMAIL_REPLY
  MANUAL_UPLOAD
}

model Organization {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  emailDomain String?
  features    Json?    // Account-level feature flags: { expenses: boolean, ap: boolean, ... }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users                  User[]
  entities               Entity[]
  groups                 Group[]
  jobs                   Job[]
  connectedEmailAccounts ConnectedEmailAccount[]
  automationRules        AutomationRule[]
  emailDrafts            EmailDraft[]
  agentSchedules         AgentSchedule[]

  @@index([slug])
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  passwordHash   String
  name           String?
  role           UserRole @default(MEMBER)
  signature      String? // User's email signature
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Auth token fields for verification, password reset, and invites
  emailVerified     Boolean   @default(false)
  verificationToken String?   @unique
  tokenExpiresAt    DateTime?

  organization      Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  emailDrafts       EmailDraft[]
  ownedJobs         Job[]             @relation("JobOwner")
  jobCollaborations JobCollaborator[]
  jobComments       JobComment[]
  reviewedItems     CollectedItem[]   @relation("CollectedItemReviewer")

  @@index([organizationId])
  @@index([email])
  @@index([verificationToken])
}

model Entity {
  id                     String      @id @default(cuid())
  firstName              String
  lastName               String?
  email                  String?
  phone                  String?
  contactType            ContactType @default(UNKNOWN)
  contactTypeCustomLabel String?
  organizationId         String
  createdAt              DateTime    @default(now())
  updatedAt              DateTime    @updatedAt

  organization   Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  groups         EntityGroup[]
  tasks          Task[]
  messages       Message[]
  reminderStates ReminderState[]
  clientJobs     Job[]             @relation("JobClient") // Jobs where this entity is the primary client
  jobLabels      JobContactLabel[] // Item-scoped labels applied to this contact

  @@index([organizationId])
  @@index([email])
  @@index([organizationId, email])
}

model Group {
  id             String   @id @default(cuid())
  name           String
  description    String?
  color          String?
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  entities     EntityGroup[]
  schedules    AgentSchedule[]

  @@index([organizationId])
}

model EntityGroup {
  id        String   @id @default(cuid())
  entityId  String
  groupId   String
  createdAt DateTime @default(now())

  entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([entityId, groupId])
  @@index([entityId])
  @@index([groupId])
}

enum ContactType {
  UNKNOWN
  EMPLOYEE
  VENDOR
  CLIENT
  CONTRACTOR
  MANAGEMENT
  CUSTOM
}

// Job represents a persistent work container (e.g., "Tax Planning - Year End 2024")
// Jobs own Tasks (requests), enabling aggregation and status tracking across recipients
enum JobStatus {
  ACTIVE    // Work in progress
  WAITING   // Waiting on external response
  COMPLETED // All work done
  ARCHIVED  // No longer active, kept for history
}

model Job {
  id             String    @id @default(cuid())
  organizationId String
  name           String    // Human-readable job name (e.g., "Tax Planning - Year End 2024")
  description    String?   // Optional detailed description
  clientId       String?   // Optional: primary client (Entity) for this job
  ownerId        String    // Required: accountable user for this job
  status         JobStatus @default(ACTIVE)
  dueDate        DateTime? // Target completion date
  labels         Json?     // Flexible tagging/categorization
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization    Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  client          Entity?           @relation("JobClient", fields: [clientId], references: [id], onDelete: SetNull)
  owner           User              @relation("JobOwner", fields: [ownerId], references: [id])
  collaborators   JobCollaborator[] // Team members who can collaborate on this job
  tasks           Task[]            // Child tasks (requests) belonging to this job
  requests        EmailDraft[]      // Request-level association
  comments        JobComment[]      // Internal collaboration comments
  collectedItems  CollectedItem[]   // Evidence/attachments collected for this job

  jobLabels       JobLabel[]        // Item-scoped labels for contacts

  @@index([organizationId])
  @@index([organizationId, status])
  @@index([clientId])
  @@index([ownerId])
  @@index([organizationId, createdAt])
}

// JobLabel defines labels that can be applied to contacts within a specific Job
// e.g., "paid", "unpaid", "pending" with metadata schemas like invoice_number, amount
model JobLabel {
  id              String   @id @default(cuid())
  jobId           String
  organizationId  String
  name            String   // "unpaid", "received", "pending"
  color           String?  // "#ef4444"
  metadataSchema  Json     @default("[]") // [{key: "invoice_number", label: "Invoice #", type: "text"}]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  job           Job               @relation(fields: [jobId], references: [id], onDelete: Cascade)
  contactLabels JobContactLabel[]

  @@unique([jobId, name])
  @@index([jobId])
  @@index([organizationId])
}

// JobContactLabel applies a label to a contact within a Job's context
// Stores the metadata values for that contact-label pair
model JobContactLabel {
  id          String   @id @default(cuid())
  jobLabelId  String
  entityId    String
  metadata    Json     @default("{}") // {invoice_number: "INV-001", amount: "500.00"}
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  jobLabel JobLabel @relation(fields: [jobLabelId], references: [id], onDelete: Cascade)
  entity   Entity   @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([jobLabelId, entityId])
  @@index([jobLabelId])
  @@index([entityId])
}

// JobCollaborator join table for team collaboration on Jobs
// This replaces a JSON array for better querying, indexing, and auditing
model JobCollaborator {
  id        String   @id @default(cuid())
  jobId     String
  userId    String
  role      String   @default("collaborator") // Future: "viewer"
  addedAt   DateTime @default(now())
  addedBy   String   // User.id who added this collaborator

  job  Job  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([jobId, userId])
  @@index([userId]) // Fast "My Jobs" query
  @@index([jobId])
}

// JobComment for internal team collaboration
model JobComment {
  id        String   @id @default(cuid())
  jobId     String
  authorId  String
  content   String
  mentions  Json?    // Array of mentioned user IDs
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  job    Job  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  author User @relation(fields: [authorId], references: [id])

  @@index([jobId])
  @@index([authorId])
}

model Task {
  id                       String        @id @default(cuid())
  jobId                    String? // Optional: parent Job for task-centric workflows
  entityId                 String? // Optional: contact may be deleted but task history preserved
  campaignName             String?
  campaignType             CampaignType?
  status                   TaskStatus    @default(AWAITING_RESPONSE)
  threadId                 String        @unique
  replyToEmail             String?
  replyToPhone             String?
  aiReasoning              Json? // Store AI reasoning as JSON
  aiSummary                String? // 2-3 sentence task summary
  aiSummaryConfidence      String? // High, Medium, Low
  aiSummaryLastMessageId   String? // Track which message summary is based on (for idempotency)
  aiVerified               Boolean?
  verifiedAt               DateTime?
  documentUrl              String?
  documentKey              String?
  hasAttachments           Boolean       @default(false)
  completionPercentage     Int? // LLM-determined completion percentage (0-100) based on reply intent
  readStatus               String? // unread | read | replied
  riskLevel                String? // high | medium | low | unknown
  riskReason               String? // Short explanation of risk level
  manualRiskOverride       String? // high | medium | low | null (if manually set)
  overrideReason           String? // Reason for manual override
  lastActivityAt           DateTime? // Last activity timestamp (opened, replied, etc.)
  deadlineDate             DateTime? // Deadline/due date for the request (set during compose)
  // Reminder configuration fields (additive, nullable for backward compatibility)
  remindersEnabled         Boolean       @default(false)
  remindersStartDelayHours Int? // Hours/days before first reminder (converted to hours)
  remindersFrequencyHours  Int? // Hours/days between reminders (converted to hours)
  remindersMaxCount        Int? // Maximum reminders (1-5)
  remindersApproved        Boolean       @default(false) // Whether user approved the sequence
  organizationId           String
  createdAt                DateTime      @default(now())
  updatedAt                DateTime      @updatedAt

  job            Job?            @relation(fields: [jobId], references: [id], onDelete: SetNull)
  entity         Entity?         @relation(fields: [entityId], references: [id], onDelete: SetNull)
  messages       Message[]
  reminderStates ReminderState[]
  collectedItems CollectedItem[] // Evidence/attachments collected for this task

  @@index([organizationId])
  @@index([jobId])
  @@index([entityId])
  @@index([status])
  @@index([threadId])
  @@index([organizationId, status])
  @@index([organizationId, campaignName])
  @@index([organizationId, campaignType])
}

model Message {
  id               String           @id @default(cuid())
  taskId           String
  entityId         String? // Optional: contact may be deleted but message history preserved
  direction        MessageDirection
  channel          MessageChannel   @default(EMAIL)
  subject          String?
  body             String?
  htmlBody         String?
  fromAddress      String
  toAddress        String
  providerId       String? // Gmail message ID or SMTP message ID
  providerData     Json? // Store full provider payload
  messageIdHeader  String? // Message-ID header from email (indexed for efficient reply matching)
  threadId         String? // Gmail thread ID (indexed for efficient reply matching)
  attachments      Json? // Store attachment metadata as JSON
  trackingToken    String?          @unique // Unique token for tracking pixel URL
  openedAt         DateTime? // First time email was opened
  openedCount      Int              @default(0) // Number of times opened
  lastOpenedAt     DateTime? // Most recent open time
  aiClassification String? // DATA, QUESTION, COMPLAINT, ACKNOWLEDGMENT, OTHER
  aiReasoning      String? // Brief explanation of classification
  isAutoReply      Boolean          @default(false) // True if this is an OOO, bounce, or auto-reply
  createdAt        DateTime         @default(now())

  entity         Entity?         @relation(fields: [entityId], references: [id], onDelete: SetNull)
  task           Task            @relation(fields: [taskId], references: [id], onDelete: Cascade)
  collectedItems CollectedItem[] // Evidence/attachments extracted from this message

  @@index([taskId])
  @@index([entityId])
  @@index([providerId])
  @@index([taskId, createdAt])
  @@index([trackingToken])
  @@index([messageIdHeader])
  @@index([threadId])
  @@index([isAutoReply])
}

model AgentSchedule {
  id             String        @id @default(cuid())
  name           String
  cronExpression String
  timezone       String        @default("UTC")
  organizationId String
  groupId        String?
  campaignName   String?
  campaignType   CampaignType?
  emailSubject   String
  emailBody      String
  htmlBody       String?
  lastRunAt      DateTime?
  nextRunAt      DateTime?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  group        Group?       @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([groupId])
  @@index([isActive, nextRunAt])
}

model ConnectedEmailAccount {
  id             String        @id @default(cuid())
  organizationId String
  email          String
  provider       EmailProvider
  accessToken    String? // Encrypted
  refreshToken   String? // Encrypted
  tokenExpiresAt DateTime?
  syncCursor     Json?
  lastSyncAt     DateTime?
  smtpHost       String?
  smtpPort       Int?
  smtpUser       String?
  smtpPassword   String? // Encrypted
  smtpSecure     Boolean       @default(true)
  isPrimary      Boolean       @default(false)
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([email])
  @@index([organizationId, isPrimary])
}

model EmailAccount {
  id             String        @id @default(cuid())
  userId         String
  organizationId String
  provider       EmailProvider
  email          String
  accessToken    String? // Encrypted
  refreshToken   String? // Encrypted
  tokenExpiresAt DateTime?
  scopes         String?
  isPrimary      Boolean       @default(false)
  isActive       Boolean       @default(true)
  lastSyncedAt   DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([organizationId])
  @@index([userId])
  @@index([email])
  @@index([organizationId, isPrimary])
  @@index([organizationId, createdAt])
}

model AutomationRule {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  trigger        String // Event that triggers the rule
  conditions     Json // Store conditions as JSON
  actions        Json // Store actions as JSON
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([isActive])
}

model EmailDraft {
  id                    String           @id @default(cuid())
  organizationId        String
  userId                String
  jobId                 String?          // Optional: parent Job for Request-level association
  prompt                String
  generatedSubject      String?
  generatedBody         String?
  generatedHtmlBody     String?
  // Personalization fields
  subjectTemplate       String? // Template with {{Tag Name}} placeholders
  bodyTemplate          String? // Template with {{Tag Name}} placeholders
  htmlBodyTemplate      String? // HTML template with {{Tag Name}} placeholders
  availableTags         Json? // Array of available tag names
  personalizationMode   String? // "none" | "contact" | "csv"
  blockOnMissingValues  Boolean          @default(true)
  deadlineDate          DateTime? // Deadline date for the request (set by user via date picker)
  // Legacy fields (keeping for backwards compatibility)
  suggestedRecipients   Json? // Store suggested entity/group IDs as JSON
  suggestedCampaignName String?
  suggestedCampaignType CampaignType?
  status                EmailDraftStatus @default(DRAFT)
  idempotencyKey        String?          @unique
  aiGenerationStatus    String? // "processing", "complete", "failed", "timeout"
  sentAt                DateTime? // Timestamp when draft was sent (for idempotency)
  sendAttemptId         String? // Unique ID for send attempt tracking
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt

  organization        Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  job                 Job?                  @relation(fields: [jobId], references: [id], onDelete: SetNull)
  personalizationData PersonalizationData[]

  @@index([organizationId])
  @@index([userId])
  @@index([jobId])
  @@index([status])
  @@index([idempotencyKey])
}

model PersonalizationData {
  id             String   @id @default(cuid())
  emailDraftId   String
  recipientEmail String
  contactId      String? // Optional reference to Entity
  dataJson       Json // Key/value map from CSV + contact fields
  renderSubject  String? // Rendered subject for this recipient
  renderBody     String? // Rendered body for this recipient
  renderHtmlBody String? // Rendered HTML body for this recipient
  renderStatus   String? // "ok" | "missing" | "failed"
  renderErrors   Json? // Array of error messages if renderStatus is "failed" or "missing"
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  emailDraft EmailDraft @relation(fields: [emailDraftId], references: [id], onDelete: Cascade)

  @@unique([emailDraftId, recipientEmail])
  @@index([emailDraftId])
  @@index([recipientEmail])
}

model ReminderState {
  id               String    @id @default(cuid())
  taskId           String // Link to Task (the request)
  entityId         String? // Recipient entity (optional: contact may be deleted)
  reminderNumber   Int // Which reminder this is (1, 2, 3, etc.)
  sentCount        Int       @default(0) // How many reminders sent (incremented when sent)
  nextSendAt       DateTime? // When next reminder should be sent (null if stopped or max reached)
  lastSentAt       DateTime? // When last reminder was sent
  stoppedReason    String? // "replied" | "max_reached" | "manual_stop" | null
  scheduledEventId String?   @unique // Inngest event ID for idempotency (prevents duplicate sends)
  organizationId   String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  task   Task    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  entity Entity? @relation(fields: [entityId], references: [id], onDelete: SetNull)

  @@unique([taskId, entityId]) // One state per task+entity
  @@index([taskId])
  @@index([entityId])
  @@index([organizationId, nextSendAt]) // For querying tasks that need reminders
  @@index([scheduledEventId]) // For idempotency checks
}

// CollectedItem represents evidence/attachments received in response to requests
// This is the core model for the Collection feature - request-scoped evidence intake
model CollectedItem {
  id              String              @id @default(cuid())
  organizationId  String
  jobId           String              // Parent checklist item (required)
  taskId          String?             // Optional: specific request/task this came from
  messageId       String?             // Optional: source message if from email
  
  // File metadata
  filename        String
  fileKey         String              // Storage key (blob or local)
  fileUrl         String?             // Cached URL for quick access
  fileSize        Int?                // Bytes
  mimeType        String?
  
  // Source tracking
  source          CollectedItemSource
  submittedBy     String?             // Email address of submitter
  submittedByName String?             // Name if available
  receivedAt      DateTime            // When the item was received
  
  // Approval workflow
  status          CollectedItemStatus @default(UNREVIEWED)
  reviewedBy      String?             // User ID who reviewed
  reviewedAt      DateTime?
  rejectionReason String?
  
  // Metadata
  notes           String?             // Internal notes
  metadata        Json?               // Extensible metadata
  
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  job             Job                 @relation(fields: [jobId], references: [id], onDelete: Cascade)
  task            Task?               @relation(fields: [taskId], references: [id], onDelete: SetNull)
  message         Message?            @relation(fields: [messageId], references: [id], onDelete: SetNull)
  reviewer        User?               @relation("CollectedItemReviewer", fields: [reviewedBy], references: [id])
  
  @@index([organizationId])
  @@index([jobId])
  @@index([taskId])
  @@index([messageId])
  @@index([status])
  @@index([jobId, status])
  @@index([organizationId, jobId])
}
