// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  // "native" = your local machine (Mac/Windows/Linux)
  // "debian-openssl-3.0.x" = Cloud Run production (node:18-slim is Debian-based)
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  MEMBER
  VIEWER
}

enum TaskType {
  GENERIC
  RECONCILIATION
  TABLE
  REPORTS
}

enum TaskStatus {
  // Current active statuses
  NO_REPLY // No reply received yet (default for new requests)
  REPLIED // Reply received from contact
  COMPLETE // Task marked as complete (manual action)
  // Legacy statuses (kept for backward compatibility with existing data)
  IN_PROGRESS // @deprecated - maps to NO_REPLY
  FULFILLED // @deprecated - maps to COMPLETE
  AWAITING_RESPONSE // @deprecated - maps to NO_REPLY
  HAS_ATTACHMENTS // @deprecated - maps to REPLIED
  VERIFYING // @deprecated - maps to REPLIED
  REJECTED // @deprecated - maps to COMPLETE
  FLAGGED // @deprecated - maps to NO_REPLY
  MANUAL_REVIEW // @deprecated - maps to NO_REPLY
  ON_HOLD // @deprecated - maps to NO_REPLY
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageChannel {
  EMAIL
  SMS
}

enum EmailProvider {
  GMAIL
  MICROSOFT
  GENERIC_SMTP
}

enum CampaignType {
  W9
  COI
  EXPENSE
  TIMESHEET
  INVOICE
  RECEIPT
  CUSTOM
}

enum EmailDraftStatus {
  DRAFT
  APPROVED
  SENT
}

// Collection feature - request-scoped evidence intake
enum CollectedItemStatus {
  UNREVIEWED
  APPROVED
  REJECTED
}

// Review workflow status for inbound messages
enum ReviewStatus {
  UNREVIEWED
  NEEDS_FOLLOW_UP
  REVIEWED
}

enum CollectedItemSource {
  EMAIL_REPLY
  MANUAL_UPLOAD
}

// Board represents a period-based checklist (e.g., "January 2025 Book Close")
// Boards group Jobs for accounting period workflows (Monday.com parity)
enum BoardStatus {
  // New action-oriented statuses
  NOT_STARTED // Work not yet begun
  IN_PROGRESS // Work actively happening
  COMPLETE // All work done
  BLOCKED // Waiting on external dependency
  ARCHIVED // Hidden from active view
  // Legacy statuses (kept for backward compatibility during migration)
  OPEN // @deprecated - use NOT_STARTED
  CLOSED // @deprecated - use COMPLETE
}

// Board cadence - what kind of time period this board represents
// FUTURE: cadence + periodStart/periodEnd enable auto-creation and AI reasoning
enum BoardCadence {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  YEAR_END
  AD_HOC
}

// Subtask status for checklist items within a Job (Monday.com subitem parity)
enum SubtaskStatus {
  NOT_STARTED
  IN_PROGRESS
  STUCK
  DONE
}

model Organization {
  id                   String   @id @default(cuid())
  name                 String
  slug                 String   @unique
  emailDomain          String?
  features             Json? // Account-level feature flags: { expenses: boolean, ap: boolean, ... }
  fiscalYearStartMonth Int      @default(1) // 1 = January, 12 = December
  timezone             String   @default("UTC") // IANA timezone e.g. "America/New_York", "Australia/Sydney"
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  users                   User[]
  entities                Entity[]
  groups                  Group[]
  taskInstances           TaskInstance[]
  taskLineages            TaskLineage[]
  importRecipes           ImportRecipe[]
  connectedEmailAccounts  ConnectedEmailAccount[]
  automationRules         AutomationRule[]
  emailDrafts             EmailDraft[]
  agentSchedules          AgentSchedule[]
  boards                  Board[]
  subtasks                Subtask[]
  attachments             Attachment[]
  emailQueue              EmailQueue[]
  reconciliations         Reconciliation[]
  reconciliationTemplates ReconciliationTemplate[]
  databases               Database[]
  reportDefinitions       ReportDefinition[]
  reportSlices            ReportSlice[]
  generatedReports        GeneratedReport[]

  @@index([slug])
}

model TaskLineage {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  description    String?
  type           TaskType
  config         Json? // Schema for TABLE, Match rules for RECONCILIATION
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization  Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  instances     TaskInstance[]
  importRecipes ImportRecipe[]

  @@index([organizationId])
}

model ImportRecipe {
  id             String   @id @default(cuid())
  organizationId String
  lineageId      String
  name           String
  mapping        Json // CSV Header -> Schema Column mapping
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  lineage      TaskLineage  @relation(fields: [lineageId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([lineageId])
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  passwordHash   String
  name           String?
  role           UserRole @default(MEMBER)
  signature      String? // User's email signature
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Auth token fields for verification, password reset, and invites
  emailVerified     Boolean   @default(false)
  verificationToken String?   @unique
  tokenExpiresAt    DateTime?

  // Onboarding tracking
  onboardingCompleted Boolean @default(false)
  onboardingDismissed Boolean @default(false)

  organization               Organization               @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  emailDrafts                EmailDraft[]
  ownedTaskInstances         TaskInstance[]             @relation("TaskInstanceOwner")
  taskInstanceCollaborations TaskInstanceCollaborator[]
  taskInstanceComments       TaskInstanceComment[]
  reviewedItems              CollectedItem[]            @relation("CollectedItemReviewer")
  ownedBoards                Board[]                    @relation("BoardOwner")
  createdBoards              Board[]                    @relation("BoardCreator")
  boardCollaborations        BoardCollaborator[]
  ownedSubtasks              Subtask[]                  @relation("SubtaskOwner")
  uploadedAttachments        Attachment[]               @relation("AttachmentUploader")
  reviewedMessages           Message[]                  @relation("MessageReviewer")
  reviewAuditLogs            ReviewAuditLog[]           @relation("ReviewAuditAuthor")
  reconciliations            Reconciliation[]           @relation("ReconciliationCreator")
  connectedEmailAccounts     ConnectedEmailAccount[]
  createdDatabases           Database[]                 @relation("DatabaseCreator")
  importedDatabases          Database[]                 @relation("DatabaseImporter")
  createdReportDefinitions   ReportDefinition[]         @relation("ReportDefinitionCreator")
  createdReportSlices        ReportSlice[]              @relation("ReportSliceCreator")

  @@index([organizationId])
  @@index([email])
  @@index([verificationToken])
}

model Entity {
  id                     String      @id @default(cuid())
  firstName              String
  lastName               String?
  email                  String?
  phone                  String?
  companyName            String? // Company name for accounting reference
  contactType            ContactType @default(UNKNOWN) // @deprecated - use isInternal instead
  contactTypeCustomLabel String? // @deprecated
  isInternal             Boolean     @default(false) // true = internal (employee), false = external (client/vendor)
  organizationId         String
  createdAt              DateTime    @default(now())
  updatedAt              DateTime    @updatedAt

  organization        Organization               @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  groups              EntityGroup[]
  requests            Request[]
  messages            Message[]
  reminderStates      ReminderState[]
  clientTaskInstances TaskInstance[]             @relation("TaskInstanceClient") // Task instances where this entity is the primary client
  taskInstanceLabels  TaskInstanceContactLabel[] // Item-scoped labels applied to this contact

  @@index([organizationId])
  @@index([email])
  @@index([organizationId, email])
  @@index([organizationId, isInternal])
}

model Group {
  id             String   @id @default(cuid())
  name           String
  description    String?
  color          String?
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  entities     EntityGroup[]
  schedules    AgentSchedule[]

  @@index([organizationId])
}

model EntityGroup {
  id        String   @id @default(cuid())
  entityId  String
  groupId   String
  createdAt DateTime @default(now())

  entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([entityId, groupId])
  @@index([entityId])
  @@index([groupId])
}

enum ContactType {
  UNKNOWN
  EMPLOYEE
  VENDOR
  CLIENT
  CONTRACTOR
  MANAGEMENT
  CUSTOM
}

// Job represents a persistent work container (e.g., "Tax Planning - Year End 2024")
// Jobs own Tasks (requests), enabling aggregation and status tracking across recipients
// Note: Enum name must match database enum name "JobStatus"
enum JobStatus {
  // New action-oriented statuses
  NOT_STARTED // Work not yet begun
  IN_PROGRESS // Work in progress
  COMPLETE // All work done
  BLOCKED // Blocked by external dependency
  // Legacy statuses (kept for backwards compatibility)
  ACTIVE // @deprecated - use NOT_STARTED or IN_PROGRESS
  WAITING // @deprecated - use IN_PROGRESS
  COMPLETED // @deprecated - use COMPLETE
  ARCHIVED // @deprecated - use COMPLETE
}

// TaskInstance represents a persistent work container for a specific period
// TaskInstances are spawned from TaskLineages and belong to a Board
model TaskInstance {
  id             String    @id @default(cuid())
  organizationId String
  lineageId      String? // Link to parent lineage (template)
  type           TaskType  @default(GENERIC)
  name           String // Human-readable job name (e.g., "Tax Planning - Year End 2024")
  description    String? // Optional detailed description
  clientId       String? // Optional: primary client (Entity) for this job
  ownerId        String // Required: accountable user for this job
  status         JobStatus @default(NOT_STARTED)
  dueDate        DateTime? // Target completion date
  labels         Json? // Flexible tagging/categorization
  boardId        String? // Optional: parent Board for period-based organization
  sortOrder      Int?      @default(0) // Order within board for drag-drop reordering
  notes          String? // User notes for this task
  customFields   Json? // Custom column data for configurable table
  structuredData Json? // Row-level data for TABLE tasks or results for RECONCILIATION
  isSnapshot     Boolean   @default(false) // If true, this instance is an immutable historical record
  
  // Report configuration (for REPORTS type tasks)
  reportDefinitionId String?
  reportSliceId      String?
  
  // Stakeholder scope for task type categorization
  stakeholderScope   String?  // "accounting" | "employee" | "external"
  
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization    Organization               @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  lineage         TaskLineage?               @relation(fields: [lineageId], references: [id], onDelete: SetNull)
  client          Entity?                    @relation("TaskInstanceClient", fields: [clientId], references: [id], onDelete: SetNull)
  owner           User                       @relation("TaskInstanceOwner", fields: [ownerId], references: [id])
  board           Board?                     @relation(fields: [boardId], references: [id], onDelete: SetNull)
  reportDefinition ReportDefinition?         @relation(fields: [reportDefinitionId], references: [id], onDelete: SetNull)
  reportSlice      ReportSlice?              @relation(fields: [reportSliceId], references: [id], onDelete: SetNull)
  collaborators   TaskInstanceCollaborator[] // Team members who can collaborate on this job
  requests        Request[] // Child tasks (requests) belonging to this job
  emailDrafts     EmailDraft[] // Request-level association
  comments        TaskInstanceComment[] // Internal collaboration comments
  collectedItems  CollectedItem[] // Evidence/attachments collected for this job
  subtasks        Subtask[] // Checklist subitems within this job
  attachments     Attachment[] // Direct file attachments on this job
  reconciliations Reconciliation[] // Document reconciliation workflows
  generatedReports GeneratedReport[] // Reports generated for this task

  taskInstanceLabels TaskInstanceLabel[] // Item-scoped labels for contacts

  @@index([organizationId])
  @@index([organizationId, status])
  @@index([clientId])
  @@index([ownerId])
  @@index([organizationId, createdAt])
  @@index([boardId])
  @@index([lineageId])
  @@map("Job")
}

// TaskInstanceLabel defines labels that can be applied to contacts within a specific TaskInstance
// e.g., "paid", "unpaid", "pending" with metadata schemas like invoice_number, amount
model TaskInstanceLabel {
  id             String   @id @default(cuid())
  taskInstanceId String   @map("jobId")
  organizationId String
  name           String // "unpaid", "received", "pending"
  color          String? // "#ef4444"
  metadataSchema Json     @default("[]") // [{key: "invoice_number", label: "Invoice #", type: "text"}]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  taskInstance  TaskInstance               @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  contactLabels TaskInstanceContactLabel[]

  @@unique([taskInstanceId, name])
  @@index([taskInstanceId])
  @@index([organizationId])
  @@map("JobLabel")
}

// TaskInstanceContactLabel applies a label to a contact within a TaskInstance's context
// Stores the metadata values for that contact-label pair
model TaskInstanceContactLabel {
  id                  String   @id @default(cuid())
  taskInstanceLabelId String   @map("jobLabelId")
  entityId            String
  metadata            Json     @default("{}") // {invoice_number: "INV-001", amount: "500.00"}
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  taskInstanceLabel TaskInstanceLabel @relation(fields: [taskInstanceLabelId], references: [id], onDelete: Cascade)
  entity            Entity            @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([taskInstanceLabelId, entityId])
  @@index([taskInstanceLabelId])
  @@index([entityId])
  @@map("JobContactLabel")
}

// TaskInstanceCollaborator join table for team collaboration on TaskInstances
// This replaces a JSON array for better querying, indexing, and auditing
model TaskInstanceCollaborator {
  id             String   @id @default(cuid())
  taskInstanceId String   @map("jobId")
  userId         String
  role           String   @default("collaborator") // Future: "viewer"
  addedAt        DateTime @default(now())
  addedBy        String // User.id who added this collaborator

  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskInstanceId, userId])
  @@index([userId]) // Fast "My Tasks" query
  @@index([taskInstanceId])
  @@map("JobCollaborator")
}

// TaskInstanceComment for internal team collaboration
model TaskInstanceComment {
  id             String   @id @default(cuid())
  taskInstanceId String   @map("jobId")
  authorId       String
  content        String
  mentions       Json? // Array of mentioned user IDs
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  author       User         @relation(fields: [authorId], references: [id])

  @@index([taskInstanceId])
  @@index([authorId])
  @@map("JobComment")
}

model Request {
  id                       String        @id @default(cuid())
  taskInstanceId           String?       @map("jobId") // Optional: parent TaskInstance for request-level association
  entityId                 String? // Optional: contact may be deleted but request history preserved
  campaignName             String?
  campaignType             CampaignType?
  status                   TaskStatus    @default(AWAITING_RESPONSE)
  threadId                 String        @unique
  replyToEmail             String?
  replyToPhone             String?
  aiReasoning              Json? // Store AI reasoning as JSON
  aiSummary                String? // 2-3 sentence task summary
  aiSummaryConfidence      String? // High, Medium, Low
  aiSummaryLastMessageId   String? // Track which message summary is based on (for idempotency)
  aiVerified               Boolean?
  verifiedAt               DateTime?
  documentUrl              String?
  documentKey              String?
  hasAttachments           Boolean       @default(false)
  completionPercentage     Int? // LLM-determined completion percentage (0-100) based on reply intent
  readStatus               String? // unread | read | replied
  riskLevel                String? // high | medium | low | unknown
  riskReason               String? // Short explanation of risk level
  manualRiskOverride       String? // high | medium | low | null (if manually set)
  overrideReason           String? // Reason for manual override
  lastActivityAt           DateTime? // Last activity timestamp (opened, replied, etc.)
  deadlineDate             DateTime? // Deadline/due date for the request (set during compose)
  // Reminder configuration fields (additive, nullable for backward compatibility)
  remindersEnabled         Boolean       @default(false)
  remindersStartDelayHours Int? // Hours/days before first reminder (converted to hours)
  remindersFrequencyHours  Int? // Hours/days between reminders (converted to hours)
  remindersMaxCount        Int? // Maximum reminders (1-5)
  remindersApproved        Boolean       @default(false) // Whether user approved the sequence

  // Period-aware scheduling (collapsed into JSON for minimal schema footprint)
  // scheduleConfig: { mode: "ad_hoc"|"period_aware", anchor?: "period_start"|"period_end",
  //                   offsetDays?: number, weekendRule?: "previous"|"next", sendTime?: "HH:mm" }
  scheduleConfig  Json? // Scheduling recipe
  scheduledSendAt DateTime? // Computed absolute send datetime (for display/audit)

  // Draft request fields (copy-on-write pattern for recurring request drafts)
  isDraft              Boolean @default(false) // True = draft copied from prior period, not yet sent
  draftSourceRequestId String? // Link to source request from prior period (for content + audit)
  draftEditedSubject   String? // Only populated if user edits the draft subject
  draftEditedBody      String? @db.Text // Only populated if user edits the draft body
  draftEditedHtmlBody  String? @db.Text // Only populated if user edits the draft HTML body

  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  taskInstance      TaskInstance?      @relation(fields: [taskInstanceId], references: [id], onDelete: SetNull)
  entity            Entity?            @relation(fields: [entityId], references: [id], onDelete: SetNull)
  messages          Message[]
  reminderStates    ReminderState[]
  collectedItems    CollectedItem[] // Evidence/attachments collected for this request
  aiRecommendations AIRecommendation[] // AI recommendations for feedback loop

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([entityId])
  @@index([status])
  @@index([threadId])
  @@index([organizationId, status])
  @@index([organizationId, campaignName])
  @@index([organizationId, campaignType])
  @@index([organizationId, isDraft]) // For filtering draft vs active requests
  @@index([draftSourceRequestId]) // For looking up source request content
  @@map("Task")
}

model Message {
  id               String           @id @default(cuid())
  requestId        String           @map("taskId")
  entityId         String? // Optional: contact may be deleted but message history preserved
  direction        MessageDirection
  channel          MessageChannel   @default(EMAIL)
  subject          String?
  body             String?
  htmlBody         String?
  fromAddress      String
  toAddress        String
  providerId       String? // Gmail message ID or SMTP message ID
  providerData     Json? // Store full provider payload
  messageIdHeader  String? // Message-ID header from email (indexed for efficient reply matching)
  threadId         String? // Gmail thread ID (indexed for efficient reply matching)
  attachments      Json? // Store attachment metadata as JSON
  trackingToken    String?          @unique // Unique token for tracking pixel URL
  openedAt         DateTime? // First time email was opened
  openedCount      Int              @default(0) // Number of times opened
  lastOpenedAt     DateTime? // Most recent open time
  aiClassification String? // DATA, QUESTION, COMPLAINT, ACKNOWLEDGMENT, OTHER
  aiReasoning      String? // Brief explanation of classification
  isAutoReply      Boolean          @default(false) // True if this is an OOO, bounce, or auto-reply
  createdAt        DateTime         @default(now())

  // Review workflow fields
  reviewStatus ReviewStatus @default(UNREVIEWED)
  reviewedAt   DateTime?
  reviewedById String?
  reviewNotes  String?

  entity            Entity?            @relation(fields: [entityId], references: [id], onDelete: SetNull)
  request           Request            @relation(fields: [requestId], references: [id], onDelete: Cascade)
  collectedItems    CollectedItem[] // Evidence/attachments extracted from this message
  reviewedBy        User?              @relation("MessageReviewer", fields: [reviewedById], references: [id])
  auditLogs         ReviewAuditLog[]
  aiRecommendations AIRecommendation[] // AI recommendations for feedback loop

  @@index([requestId])
  @@index([entityId])
  @@index([providerId])
  @@index([requestId, createdAt])
  @@index([trackingToken])
  @@index([messageIdHeader])
  @@index([threadId])
  @@index([isAutoReply])
  @@index([reviewStatus])
}

model AgentSchedule {
  id             String        @id @default(cuid())
  name           String
  cronExpression String
  timezone       String        @default("UTC")
  organizationId String
  groupId        String?
  campaignName   String?
  campaignType   CampaignType?
  emailSubject   String
  emailBody      String
  htmlBody       String?
  lastRunAt      DateTime?
  nextRunAt      DateTime?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  group        Group?       @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([groupId])
  @@index([isActive, nextRunAt])
}

model ConnectedEmailAccount {
  id             String        @id @default(cuid())
  organizationId String
  userId         String? // User who connected this account (null = legacy/shared)
  email          String
  provider       EmailProvider
  accessToken    String? // Encrypted
  refreshToken   String? // Encrypted
  tokenExpiresAt DateTime?
  syncCursor     Json?
  lastSyncAt     DateTime?
  smtpHost       String?
  smtpPort       Int?
  smtpUser       String?
  smtpPassword   String? // Encrypted
  smtpSecure     Boolean       @default(true)
  isPrimary      Boolean       @default(false)
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User?        @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([userId])
  @@index([email])
  @@index([organizationId, isPrimary])
  @@index([organizationId, userId])
}

model AutomationRule {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  trigger        String // Event that triggers the rule
  conditions     Json // Store conditions as JSON
  actions        Json // Store actions as JSON
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([isActive])
}

model EmailDraft {
  id                    String           @id @default(cuid())
  organizationId        String
  userId                String
  taskInstanceId        String?          @map("jobId") // Optional: parent TaskInstance
  prompt                String
  generatedSubject      String?
  generatedBody         String?
  generatedHtmlBody     String?
  // Personalization fields
  subjectTemplate       String? // Template with {{Tag Name}} placeholders
  bodyTemplate          String? // Template with {{Tag Name}} placeholders
  htmlBodyTemplate      String? // HTML template with {{Tag Name}} placeholders
  availableTags         Json? // Array of available tag names
  personalizationMode   String? // "none" | "contact" | "csv"
  blockOnMissingValues  Boolean          @default(true)
  deadlineDate          DateTime? // Deadline date for the request
  // Legacy fields (keeping for backwards compatibility)
  suggestedRecipients   Json? // Store suggested entity/group IDs as JSON
  suggestedCampaignName String?
  suggestedCampaignType CampaignType?
  status                EmailDraftStatus @default(DRAFT)
  idempotencyKey        String?          @unique
  aiGenerationStatus    String? // "processing", "complete", "failed", "timeout"
  sentAt                DateTime? // Timestamp when draft was sent (for idempotency)
  sendAttemptId         String? // Unique ID for send attempt tracking
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt

  organization        Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  taskInstance        TaskInstance?         @relation(fields: [taskInstanceId], references: [id], onDelete: SetNull)
  personalizationData PersonalizationData[]

  @@index([organizationId])
  @@index([userId])
  @@index([taskInstanceId])
  @@index([status])
  @@index([idempotencyKey])
}

model PersonalizationData {
  id             String   @id @default(cuid())
  emailDraftId   String
  recipientEmail String
  contactId      String? // Optional reference to Entity
  dataJson       Json // Key/value map from CSV + contact fields
  renderSubject  String? // Rendered subject for this recipient
  renderBody     String? // Rendered body for this recipient
  renderHtmlBody String? // Rendered HTML body for this recipient
  renderStatus   String? // "ok" | "missing" | "failed"
  renderErrors   Json? // Array of error messages if renderStatus is "failed" or "missing"
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  emailDraft EmailDraft @relation(fields: [emailDraftId], references: [id], onDelete: Cascade)

  @@unique([emailDraftId, recipientEmail])
  @@index([emailDraftId])
  @@index([recipientEmail])
}

model ReminderState {
  id               String    @id @default(cuid())
  requestId        String    @map("taskId") // Link to Request (the threaded communication)
  entityId         String? // Recipient entity (optional: contact may be deleted)
  reminderNumber   Int // Which reminder this is (1, 2, 3, etc.)
  sentCount        Int       @default(0) // How many reminders sent (incremented when sent)
  nextSendAt       DateTime? // When next reminder should be sent (null if stopped or max reached)
  lastSentAt       DateTime? // When last reminder was sent
  stoppedReason    String? // "replied" | "max_reached" | "manual_stop" | null
  scheduledEventId String?   @unique // Inngest event ID for idempotency (prevents duplicate sends)
  organizationId   String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)
  entity  Entity? @relation(fields: [entityId], references: [id], onDelete: SetNull)

  @@unique([requestId, entityId]) // One state per request+entity
  @@index([requestId])
  @@index([entityId])
  @@index([organizationId, nextSendAt]) // For querying requests that need reminders
  @@index([scheduledEventId]) // For idempotency checks
}

// CollectedItem represents evidence/attachments received in response to requests
// This is the core model for the Collection feature - request-scoped evidence intake
model CollectedItem {
  id             String  @id @default(cuid())
  organizationId String
  taskInstanceId String  @map("jobId") // Parent task instance (required)
  requestId      String? @map("taskId") // Optional: specific request this came from
  messageId      String? // Optional: source message if from email

  // File metadata
  filename String
  fileKey  String // Storage key (blob or local)
  fileUrl  String? // Cached URL for quick access
  fileSize Int? // Bytes
  mimeType String?

  // Source tracking
  source          CollectedItemSource
  submittedBy     String? // Email address of submitter
  submittedByName String? // Name if available
  receivedAt      DateTime // When the item was received

  // Approval workflow
  status          CollectedItemStatus @default(UNREVIEWED)
  reviewedBy      String? // User ID who reviewed
  reviewedAt      DateTime?
  rejectionReason String?

  // Metadata
  notes    String? // Internal notes
  metadata Json? // Extensible metadata

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  request      Request?     @relation(fields: [requestId], references: [id], onDelete: SetNull)
  message      Message?     @relation(fields: [messageId], references: [id], onDelete: SetNull)
  reviewer     User?        @relation("CollectedItemReviewer", fields: [reviewedBy], references: [id])

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([requestId])
  @@index([messageId])
  @@index([status])
  @@index([taskInstanceId, status])
  @@index([organizationId, taskInstanceId])
}

// Board represents a period-based checklist (e.g., "January 2025 Book Close")
// Boards group Jobs for accounting period workflows (Monday.com parity)
model Board {
  id             String      @id @default(cuid())
  organizationId String
  name           String // "January 2025 Book Close", "Year-End Close 2024"
  description    String?
  status         BoardStatus @default(NOT_STARTED)

  // Ownership (nullable during migration, will become required after data backfill)
  ownerId String? // Accountable user for this board

  // Time metadata - enables filtering, sorting, and future auto-creation
  cadence     BoardCadence? // Type of time period (Monthly, Weekly, etc.)
  periodStart DateTime? // Start of the time period
  periodEnd   DateTime? // End of the time period

  // Automation settings (UI config, automation logic not yet implemented)
  automationEnabled Boolean @default(false) // Auto-create next period's board
  skipWeekends      Boolean @default(true) // For DAILY cadence: skip weekends

  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  organization     Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  owner            User?               @relation("BoardOwner", fields: [ownerId], references: [id])
  createdBy        User                @relation("BoardCreator", fields: [createdById], references: [id])
  collaborators    BoardCollaborator[]
  taskInstances    TaskInstance[]
  generatedReports GeneratedReport[]   // Reports generated for this period

  @@index([organizationId])
  @@index([organizationId, status])
  @@index([ownerId])
}

// BoardCollaborator join table for team collaboration on Boards
model BoardCollaborator {
  id      String   @id @default(cuid())
  boardId String
  userId  String
  role    String   @default("collaborator") // Future: "viewer"
  addedAt DateTime @default(now())
  addedBy String // User.id who added this collaborator

  board Board @relation(fields: [boardId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([boardId, userId])
  @@index([userId])
  @@index([boardId])
}

// Subtask represents a checklist item within a Job (Monday.com subitem parity)
// Subtasks have their own owner, status, due date, and attachments
model Subtask {
  id             String        @id @default(cuid())
  organizationId String
  taskInstanceId String        @map("jobId")
  title          String
  description    String?
  ownerId        String? // Nullable - Monday allows unassigned subitems
  status         SubtaskStatus @default(NOT_STARTED)
  dueDate        DateTime?
  sortOrder      Int           @default(0) // Order within task for drag-drop reordering
  completedAt    DateTime? // Timestamp when marked as DONE
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskInstance TaskInstance @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  owner        User?        @relation("SubtaskOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  attachments  Attachment[]

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([ownerId])
  @@index([taskInstanceId, sortOrder])
}

// Attachment represents a direct file upload on a TaskInstance or Subtask
// Distinct from CollectedItem which is for inbound email attachments
model Attachment {
  id             String   @id @default(cuid())
  organizationId String
  taskInstanceId String?  @map("jobId") // One of taskInstanceId or subtaskId must be set
  subtaskId      String?
  filename       String
  fileKey        String // Storage key
  fileUrl        String? // Cached URL
  fileSize       Int? // Bytes
  mimeType       String?
  uploadedById   String
  createdAt      DateTime @default(now())

  organization Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskInstance TaskInstance? @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  subtask      Subtask?      @relation(fields: [subtaskId], references: [id], onDelete: Cascade)
  uploadedBy   User          @relation("AttachmentUploader", fields: [uploadedById], references: [id])

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([subtaskId])
}

// EmailSendAudit provides a persistent audit trail for all email sends
// Critical for debugging, compliance, and customer support
enum EmailSendResult {
  SUCCESS
  FAILED
  BLOCKED
  RATE_LIMITED
  QUEUED // Email was queued for later due to rate limiting
}

// EmailQueue stores emails that were rate-limited and need to be sent later
// A scheduled job processes this queue when rate limits allow
enum EmailQueueStatus {
  PENDING // Waiting to be sent
  PROCESSING // Currently being processed
  SENT // Successfully sent
  FAILED // Failed after max retries
  CANCELLED // Manually cancelled
}

model EmailQueue {
  id             String  @id @default(cuid())
  organizationId String
  userId         String? // User who initiated the send
  taskInstanceId String? @map("jobId") // Related task instance
  requestId      String? @map("taskId") // Related request (if updating existing)

  // Email details (stored for retry)
  toEmail   String
  subject   String
  body      String  @db.Text
  htmlBody  String? @db.Text
  accountId String? // Email account to send from

  // Queue management
  status        EmailQueueStatus @default(PENDING)
  priority      Int              @default(0) // Higher = more urgent
  attempts      Int              @default(0)
  maxAttempts   Int              @default(3)
  lastAttemptAt DateTime?
  nextAttemptAt DateTime // When to try sending next

  // Error tracking
  lastError String?

  // Metadata for the original send request
  metadata Json? // Original send parameters (deadlineDate, remindersConfig, etc.)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([status, nextAttemptAt]) // For queue processing
  @@index([toEmail])
  @@index([createdAt])
}

// ReviewAuditLog provides audit trail for review actions
model ReviewAuditLog {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  action    String // "marked_reviewed" | "marked_needs_follow_up" | "reply_sent" | "follow_up_created"
  metadata  Json?
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation("ReviewAuditAuthor", fields: [userId], references: [id])

  @@index([messageId])
  @@index([userId])
  @@index([createdAt])
}

model EmailSendAudit {
  id             String  @id @default(cuid())
  organizationId String
  userId         String? // User who initiated the send (null for system sends)
  taskInstanceId String? @map("jobId") // Related task instance if applicable
  requestId      String? @map("taskId") // Related request if applicable
  emailDraftId   String? // Related email draft if applicable

  // Send details
  fromEmail      String
  toEmail        String // Single recipient (one row per recipient for bulk)
  subject        String
  recipientCount Int    @default(1) // For bulk sends, total recipients in batch

  // Result tracking
  result       EmailSendResult
  errorMessage String? // Error details if failed
  errorCode    String? // Provider error code if available

  // Provider details
  provider   EmailProvider? // GMAIL, MICROSOFT, GENERIC_SMTP
  providerId String? // Message ID from provider

  // Metadata
  ipAddress String? // Request IP for audit
  userAgent String? // Request user agent
  metadata  Json? // Additional context (e.g., personalization mode, reminder number)

  createdAt DateTime @default(now())

  @@index([organizationId])
  @@index([organizationId, createdAt])
  @@index([userId])
  @@index([taskInstanceId])
  @@index([requestId])
  @@index([toEmail])
  @@index([result])
  @@index([createdAt])
}

// Column configuration for Monday.com-style configurable task tables
model JobColumnConfig {
  id             String   @id @default(cuid())
  organizationId String   @unique // One config per organization
  boardId        String? // Optional: board-specific config (null = global default)
  columns        Json // Array of column definitions: { id, type, label, width, visible, order }
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([organizationId, boardId])
  @@index([organizationId])
}

// AI recommendation storage for feedback loop
// Persists AI analysis results and links them to human decisions
model AIRecommendation {
  id             String @id @default(cuid())
  organizationId String
  messageId      String
  requestId      String @map("taskId")

  // Denormalized for metrics queries
  campaignType CampaignType?

  // AI recommendation
  recommendedAction String // "REVIEWED" | "NEEDS_FOLLOW_UP" (matches ReviewStatus)
  reasoning         String // Short explanation
  summaryBullets    Json? // Array of summary points
  findings          Json? // Array of findings

  // Model tracking
  model         String @default("gpt-4o-mini")
  promptVersion String @default("v1")

  // Draft reply (generated with memory, persisted for idempotency)
  draftReply         String? // Pre-filled draft reply text
  draftPromptVersion String? // Track draft prompt version separately

  // Human reconciliation (filled when user acts)
  humanAction  String? // Actual ReviewStatus chosen
  agreedWithAI Boolean? // Computed: recommendedAction == humanAction
  humanActedAt DateTime?

  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([organizationId, createdAt])
  @@index([messageId])
  @@index([organizationId, campaignType, agreedWithAI])
}

// Reconciliation status for the LLM-powered document comparison workflow
enum ReconciliationStatus {
  PENDING // Documents uploaded, waiting for processing
  PROCESSING // LLM is analyzing the documents
  COMPLETED // Analysis complete with results
  FAILED // Processing failed
}

// Reconciliation represents a comparison between two documents (e.g., Excel spreadsheets)
// Used for AI-powered document reconciliation workflows in accounting
model Reconciliation {
  id             String @id @default(cuid())
  organizationId String
  taskInstanceId String @map("jobId") // Parent task instance (TaskInstance)

  // ANCHOR Document (Source of Truth) - stored in document1 for backwards compatibility
  document1Key      String // Storage key (blob)
  document1Name     String // Original filename
  document1Url      String? // Cached URL for preview
  document1Size     Int? // File size in bytes
  document1MimeType String? // MIME type (application/pdf, image/png, etc.)

  // FIRST Supporting Document - stored in document2 for backwards compatibility
  document2Key      String // Storage key (blob)
  document2Name     String // Original filename
  document2Url      String? // Cached URL for preview
  document2Size     Int? // File size in bytes
  document2MimeType String? // MIME type (application/pdf, image/png, etc.)

  // Additional supporting documents (beyond document2)
  // Array of { key, name, url, size, uploadOrder, mimeType }
  supportingDocuments Json?

  // Accounting context
  anchorRole      String? // "General Ledger", "Control Account", "AP Balance"
  boardPeriodName String? // Cached board name + period for context

  // Processing status
  status       ReconciliationStatus @default(PENDING)
  errorMessage String? // Error details if failed

  // Results (populated after processing)
  summary        String? // Human-readable summary
  matchedCount   Int? // Number of matched items
  unmatchedCount Int? // Number of unmatched items
  totalRows      Int? // Total rows analyzed
  result         Json? // Detailed reconciliation result (includes reconciliationIntent)
  discrepancies  Json? // List of discrepancies found

  // V1 Enhanced AI output
  confidenceScore    Int? // 0-100 accounting confidence
  keyFindings        Json? // Bulleted findings array
  suggestedNextSteps Json? // Bulleted next steps array

  // Recurring template reference
  templateId String? // Links to ReconciliationTemplate

  // Metadata
  createdById String
  processedAt DateTime? // When processing completed
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  organization Organization            @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskInstance TaskInstance            @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  createdBy    User                    @relation("ReconciliationCreator", fields: [createdById], references: [id])
  template     ReconciliationTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([taskInstanceId])
  @@index([status])
  @@index([organizationId, taskInstanceId])
  @@index([templateId])
}

// ReconciliationTemplate - stores configuration for recurring reconciliations
model ReconciliationTemplate {
  id               String   @id @default(cuid())
  organizationId   String
  name             String // "Monthly Bank Recon", derived from task name
  anchorRole       String // "General Ledger", "Control Account"
  supportingRoles  Json // ["Bank Statement", "Credit Card Statement"]
  defaultIntent    String? // "ROW_LEVEL", "TOTALS_ONLY", etc.
  priorExplanation String? // Reference explanation from last successful run
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  organization    Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  reconciliations Reconciliation[]

  @@unique([organizationId, name])
  @@index([organizationId])
}

// Database represents a structured data store with schema and rows
// This is the core model for the Databases feature - standalone structured data management
model Database {
  id              String   @id @default(cuid())
  name            String
  description     String?
  organizationId  String
  
  // Schema definition (JSON) - DatabaseSchema type
  // { columns: DatabaseSchemaColumn[], version: number }
  schema          Json
  identifierKeys  Json     // String[] - Column keys that together form the unique row identifier (composite key)
  
  // Current data (JSON array of rows) - DatabaseRow[]
  rows            Json     @default("[]")
  rowCount        Int      @default(0)
  
  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdById     String
  lastImportedAt  DateTime?
  lastImportedById String?
  
  organization       Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdBy          User               @relation("DatabaseCreator", fields: [createdById], references: [id])
  lastImportedBy     User?              @relation("DatabaseImporter", fields: [lastImportedById], references: [id])
  reportDefinitions  ReportDefinition[]
  
  @@index([organizationId])
  @@index([organizationId, name])
}

// ReportDefinition represents an Excel-like report template
// Users define columns (source + formula) and formula rows (aggregations)
// The report renders data from a linked Database
model ReportDefinition {
  id              String   @id @default(cuid())
  name            String
  description     String?
  organizationId  String
  databaseId      String
  
  // Period configuration
  cadence         String   // "daily" | "monthly" | "quarterly" | "annual"
  dateColumnKey   String   // Database column key containing date data for period filtering
  
  // Layout mode: "standard" (rows=db rows, cols=selected) or "pivot" (cols=pivot values, rows=metrics)
  layout          String   @default("standard")
  
  // === Standard layout fields ===
  // Column configuration (selected database columns + formula columns)
  // Array of: { key, label, type: "source"|"formula", sourceColumnKey?, expression?, dataType, order }
  columns         Json     @default("[]")
  
  // Formula rows (aggregation rows at bottom, like Excel SUM rows)
  // Array of: { key, label, columnFormulas: { [colKey]: "SUM"|"AVG"|expression }, order }
  formulaRows     Json     @default("[]")
  
  // === Pivot layout fields ===
  // Database column whose unique values become column headers (e.g., project_name)
  pivotColumnKey  String?
  
  // Metric rows for pivot layout
  // Array of: { key, label, type: "source"|"formula", sourceColumnKey?, expression?, format, order }
  metricRows      Json     @default("[]")
  
  // Formula columns for pivot layout - computed columns that aggregate across pivot columns
  // Array of: { key, label, expression, order }
  pivotFormulaColumns Json @default("[]")
  
  // Variance analysis configuration
  compareMode     String   @default("none")  // "none" | "mom" | "yoy"
  
  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdById     String
  
  organization     Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  database         Database         @relation(fields: [databaseId], references: [id], onDelete: Cascade)
  createdBy        User             @relation("ReportDefinitionCreator", fields: [createdById], references: [id])
  slices           ReportSlice[]
  taskInstances    TaskInstance[]   // Tasks that use this report template
  generatedReports GeneratedReport[] // Reports generated from this template
  
  @@index([organizationId])
  @@index([databaseId])
}

// ReportSlice represents a saved, reusable "view" of a ReportDefinition
// It stores filter bindings (e.g., { pm: "Caleb", brand: "Chipotle" }) without hardcoding period
// Slices enable quick report viewing by audience and will be referenced by tasks in the future
model ReportSlice {
  id                 String   @id @default(cuid())
  organizationId     String
  reportDefinitionId String
  name               String
  
  // Filter bindings as JSON: { "pm": "Caleb", "brand": "Chipotle" }
  // Applied after period filtering and before layout/formula evaluation
  filterBindings     Json     @default("{}")
  
  // Metadata
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  createdById        String
  
  organization       Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  reportDefinition   ReportDefinition @relation(fields: [reportDefinitionId], references: [id], onDelete: Cascade)
  createdBy          User             @relation("ReportSliceCreator", fields: [createdById], references: [id])
  taskInstances      TaskInstance[]   // Tasks that use this slice
  generatedReports   GeneratedReport[] // Reports generated with this slice
  
  @@unique([reportDefinitionId, name])
  @@index([organizationId, reportDefinitionId])
}

// GeneratedReport stores the output of a report for a specific period
// Created automatically when a board with REPORTS tasks completes
model GeneratedReport {
  id                 String   @id @default(cuid())
  organizationId     String
  reportDefinitionId String
  reportSliceId      String?
  taskInstanceId     String   // Source task that triggered generation
  boardId            String   // Board period that was completed
  periodKey          String   // e.g., "2026-01" for monthly, "2026-Q1" for quarterly
  
  // Snapshot of report output at generation time
  data               Json     // { columns, rows, formulaRows, metrics, etc. }
  
  // Metadata
  generatedAt        DateTime @default(now())
  generatedBy        String   // "system" or userId
  
  organization       Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  reportDefinition   ReportDefinition @relation(fields: [reportDefinitionId], references: [id], onDelete: Cascade)
  reportSlice        ReportSlice?     @relation(fields: [reportSliceId], references: [id], onDelete: SetNull)
  taskInstance       TaskInstance     @relation(fields: [taskInstanceId], references: [id], onDelete: Cascade)
  board              Board            @relation(fields: [boardId], references: [id], onDelete: Cascade)
  
  @@index([organizationId, periodKey])
  @@index([reportDefinitionId])
  @@index([boardId])
  @@index([taskInstanceId])
}

