// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  // "native" = your local machine (Mac/Windows/Linux)
  // "debian-openssl-3.0.x" = Cloud Run production (node:18-slim is Debian-based)
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  MEMBER
  VIEWER
}

enum TaskStatus {
  // Current active statuses
  NO_REPLY          // No reply received yet (default for new requests)
  REPLIED           // Reply received from contact
  COMPLETE          // Task marked as complete (manual action)
  // Legacy statuses (kept for backward compatibility with existing data)
  IN_PROGRESS       // @deprecated - maps to NO_REPLY
  FULFILLED         // @deprecated - maps to COMPLETE
  AWAITING_RESPONSE // @deprecated - maps to NO_REPLY
  HAS_ATTACHMENTS   // @deprecated - maps to REPLIED
  VERIFYING         // @deprecated - maps to REPLIED
  REJECTED          // @deprecated - maps to COMPLETE
  FLAGGED           // @deprecated - maps to NO_REPLY
  MANUAL_REVIEW     // @deprecated - maps to NO_REPLY
  ON_HOLD           // @deprecated - maps to NO_REPLY
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageChannel {
  EMAIL
  SMS
}

enum EmailProvider {
  GMAIL
  MICROSOFT
  GENERIC_SMTP
}

enum CampaignType {
  W9
  COI
  EXPENSE
  TIMESHEET
  INVOICE
  RECEIPT
  CUSTOM
}

enum EmailDraftStatus {
  DRAFT
  APPROVED
  SENT
}

// Collection feature - request-scoped evidence intake
enum CollectedItemStatus {
  UNREVIEWED
  APPROVED
  REJECTED
}

// Review workflow status for inbound messages
enum ReviewStatus {
  UNREVIEWED
  NEEDS_FOLLOW_UP
  REVIEWED
}

enum CollectedItemSource {
  EMAIL_REPLY
  MANUAL_UPLOAD
}

// Board represents a period-based checklist (e.g., "January 2025 Book Close")
// Boards group Jobs for accounting period workflows (Monday.com parity)
enum BoardStatus {
  // New action-oriented statuses
  NOT_STARTED  // Work not yet begun
  IN_PROGRESS  // Work actively happening
  COMPLETE     // All work done
  BLOCKED      // Waiting on external dependency
  ARCHIVED     // Hidden from active view
  // Legacy statuses (kept for backward compatibility during migration)
  OPEN         // @deprecated - use NOT_STARTED
  CLOSED       // @deprecated - use COMPLETE
}

// Board cadence - what kind of time period this board represents
// FUTURE: cadence + periodStart/periodEnd enable auto-creation and AI reasoning
enum BoardCadence {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  YEAR_END
  AD_HOC
}

// Subtask status for checklist items within a Job (Monday.com subitem parity)
enum SubtaskStatus {
  NOT_STARTED
  IN_PROGRESS
  STUCK
  DONE
}

model Organization {
  id                   String   @id @default(cuid())
  name                 String
  slug                 String   @unique
  emailDomain          String?
  features             Json?    // Account-level feature flags: { expenses: boolean, ap: boolean, ... }
  fiscalYearStartMonth Int      @default(1) // 1 = January, 12 = December
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  users                  User[]
  entities               Entity[]
  groups                 Group[]
  jobs                   Job[]
  connectedEmailAccounts ConnectedEmailAccount[]
  automationRules        AutomationRule[]
  emailDrafts            EmailDraft[]
  agentSchedules         AgentSchedule[]
  boards                 Board[]
  subtasks               Subtask[]
  attachments            Attachment[]
  emailQueue             EmailQueue[]
  reconciliations        Reconciliation[]

  @@index([slug])
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  passwordHash   String
  name           String?
  role           UserRole @default(MEMBER)
  signature      String? // User's email signature
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Auth token fields for verification, password reset, and invites
  emailVerified     Boolean   @default(false)
  verificationToken String?   @unique
  tokenExpiresAt    DateTime?

  // Onboarding tracking
  onboardingCompleted Boolean @default(false)
  onboardingDismissed Boolean @default(false)

  organization        Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  emailDrafts         EmailDraft[]
  ownedJobs           Job[]               @relation("JobOwner")
  jobCollaborations   JobCollaborator[]
  jobComments         JobComment[]
  reviewedItems       CollectedItem[]     @relation("CollectedItemReviewer")
  ownedBoards         Board[]             @relation("BoardOwner")
  createdBoards       Board[]             @relation("BoardCreator")
  boardCollaborations BoardCollaborator[]
  ownedSubtasks       Subtask[]           @relation("SubtaskOwner")
  uploadedAttachments Attachment[]        @relation("AttachmentUploader")
  reviewedMessages       Message[]               @relation("MessageReviewer")
  reviewAuditLogs        ReviewAuditLog[]        @relation("ReviewAuditAuthor")
  reconciliations        Reconciliation[]        @relation("ReconciliationCreator")
  connectedEmailAccounts ConnectedEmailAccount[]

  @@index([organizationId])
  @@index([email])
  @@index([verificationToken])
}

model Entity {
  id                     String      @id @default(cuid())
  firstName              String
  lastName               String?
  email                  String?
  phone                  String?
  companyName            String?     // Company name for accounting reference
  contactType            ContactType @default(UNKNOWN)
  contactTypeCustomLabel String?
  organizationId         String
  createdAt              DateTime    @default(now())
  updatedAt              DateTime    @updatedAt

  organization   Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  groups         EntityGroup[]
  tasks          Task[]
  messages       Message[]
  reminderStates ReminderState[]
  clientJobs     Job[]             @relation("JobClient") // Jobs where this entity is the primary client
  jobLabels      JobContactLabel[] // Item-scoped labels applied to this contact

  @@index([organizationId])
  @@index([email])
  @@index([organizationId, email])
}

model Group {
  id             String   @id @default(cuid())
  name           String
  description    String?
  color          String?
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  entities     EntityGroup[]
  schedules    AgentSchedule[]

  @@index([organizationId])
}

model EntityGroup {
  id        String   @id @default(cuid())
  entityId  String
  groupId   String
  createdAt DateTime @default(now())

  entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([entityId, groupId])
  @@index([entityId])
  @@index([groupId])
}

enum ContactType {
  UNKNOWN
  EMPLOYEE
  VENDOR
  CLIENT
  CONTRACTOR
  MANAGEMENT
  CUSTOM
}

// Job represents a persistent work container (e.g., "Tax Planning - Year End 2024")
// Jobs own Tasks (requests), enabling aggregation and status tracking across recipients
enum JobStatus {
  // New action-oriented statuses
  NOT_STARTED  // Work not yet begun
  IN_PROGRESS  // Work in progress
  COMPLETE     // All work done
  BLOCKED      // Blocked by external dependency
  // Legacy statuses (kept for backwards compatibility)
  ACTIVE       // @deprecated - use NOT_STARTED or IN_PROGRESS
  WAITING      // @deprecated - use IN_PROGRESS
  COMPLETED    // @deprecated - use COMPLETE
  ARCHIVED     // @deprecated - use COMPLETE
}

model Job {
  id             String    @id @default(cuid())
  organizationId String
  name           String    // Human-readable job name (e.g., "Tax Planning - Year End 2024")
  description    String?   // Optional detailed description
  clientId       String?   // Optional: primary client (Entity) for this job
  ownerId        String    // Required: accountable user for this job
  status         JobStatus @default(NOT_STARTED)
  dueDate        DateTime? // Target completion date
  labels         Json?     // Flexible tagging/categorization
  boardId        String?   // Optional: parent Board for period-based organization
  sortOrder      Int?      @default(0) // Order within board for drag-drop reordering
  notes          String?   // User notes for this task
  customFields   Json?     // Custom column data for configurable table
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization    Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  client          Entity?           @relation("JobClient", fields: [clientId], references: [id], onDelete: SetNull)
  owner           User              @relation("JobOwner", fields: [ownerId], references: [id])
  board           Board?            @relation(fields: [boardId], references: [id], onDelete: SetNull)
  collaborators   JobCollaborator[] // Team members who can collaborate on this job
  tasks           Task[]            // Child tasks (requests) belonging to this job
  requests        EmailDraft[]      // Request-level association
  comments        JobComment[]      // Internal collaboration comments
  collectedItems   CollectedItem[]   // Evidence/attachments collected for this job
  subtasks         Subtask[]         // Checklist subitems within this job
  attachments      Attachment[]      // Direct file attachments on this job
  reconciliations  Reconciliation[]  // Document reconciliation workflows

  jobLabels       JobLabel[]        // Item-scoped labels for contacts

  @@index([organizationId])
  @@index([organizationId, status])
  @@index([clientId])
  @@index([ownerId])
  @@index([organizationId, createdAt])
  @@index([boardId])
}

// JobLabel defines labels that can be applied to contacts within a specific Job
// e.g., "paid", "unpaid", "pending" with metadata schemas like invoice_number, amount
model JobLabel {
  id              String   @id @default(cuid())
  jobId           String
  organizationId  String
  name            String   // "unpaid", "received", "pending"
  color           String?  // "#ef4444"
  metadataSchema  Json     @default("[]") // [{key: "invoice_number", label: "Invoice #", type: "text"}]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  job           Job               @relation(fields: [jobId], references: [id], onDelete: Cascade)
  contactLabels JobContactLabel[]

  @@unique([jobId, name])
  @@index([jobId])
  @@index([organizationId])
}

// JobContactLabel applies a label to a contact within a Job's context
// Stores the metadata values for that contact-label pair
model JobContactLabel {
  id          String   @id @default(cuid())
  jobLabelId  String
  entityId    String
  metadata    Json     @default("{}") // {invoice_number: "INV-001", amount: "500.00"}
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  jobLabel JobLabel @relation(fields: [jobLabelId], references: [id], onDelete: Cascade)
  entity   Entity   @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([jobLabelId, entityId])
  @@index([jobLabelId])
  @@index([entityId])
}

// JobCollaborator join table for team collaboration on Jobs
// This replaces a JSON array for better querying, indexing, and auditing
model JobCollaborator {
  id        String   @id @default(cuid())
  jobId     String
  userId    String
  role      String   @default("collaborator") // Future: "viewer"
  addedAt   DateTime @default(now())
  addedBy   String   // User.id who added this collaborator

  job  Job  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([jobId, userId])
  @@index([userId]) // Fast "My Jobs" query
  @@index([jobId])
}

// JobComment for internal team collaboration
model JobComment {
  id        String   @id @default(cuid())
  jobId     String
  authorId  String
  content   String
  mentions  Json?    // Array of mentioned user IDs
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  job    Job  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  author User @relation(fields: [authorId], references: [id])

  @@index([jobId])
  @@index([authorId])
}

model Task {
  id                       String        @id @default(cuid())
  jobId                    String? // Optional: parent Job for task-centric workflows
  entityId                 String? // Optional: contact may be deleted but task history preserved
  campaignName             String?
  campaignType             CampaignType?
  status                   TaskStatus    @default(AWAITING_RESPONSE)
  threadId                 String        @unique
  replyToEmail             String?
  replyToPhone             String?
  aiReasoning              Json? // Store AI reasoning as JSON
  aiSummary                String? // 2-3 sentence task summary
  aiSummaryConfidence      String? // High, Medium, Low
  aiSummaryLastMessageId   String? // Track which message summary is based on (for idempotency)
  aiVerified               Boolean?
  verifiedAt               DateTime?
  documentUrl              String?
  documentKey              String?
  hasAttachments           Boolean       @default(false)
  completionPercentage     Int? // LLM-determined completion percentage (0-100) based on reply intent
  readStatus               String? // unread | read | replied
  riskLevel                String? // high | medium | low | unknown
  riskReason               String? // Short explanation of risk level
  manualRiskOverride       String? // high | medium | low | null (if manually set)
  overrideReason           String? // Reason for manual override
  lastActivityAt           DateTime? // Last activity timestamp (opened, replied, etc.)
  deadlineDate             DateTime? // Deadline/due date for the request (set during compose)
  // Reminder configuration fields (additive, nullable for backward compatibility)
  remindersEnabled         Boolean       @default(false)
  remindersStartDelayHours Int? // Hours/days before first reminder (converted to hours)
  remindersFrequencyHours  Int? // Hours/days between reminders (converted to hours)
  remindersMaxCount        Int? // Maximum reminders (1-5)
  remindersApproved        Boolean       @default(false) // Whether user approved the sequence
  organizationId           String
  createdAt                DateTime      @default(now())
  updatedAt                DateTime      @updatedAt

  job               Job?               @relation(fields: [jobId], references: [id], onDelete: SetNull)
  entity            Entity?            @relation(fields: [entityId], references: [id], onDelete: SetNull)
  messages          Message[]
  reminderStates    ReminderState[]
  collectedItems    CollectedItem[]    // Evidence/attachments collected for this task
  aiRecommendations AIRecommendation[] // AI recommendations for feedback loop

  @@index([organizationId])
  @@index([jobId])
  @@index([entityId])
  @@index([status])
  @@index([threadId])
  @@index([organizationId, status])
  @@index([organizationId, campaignName])
  @@index([organizationId, campaignType])
}

model Message {
  id               String           @id @default(cuid())
  taskId           String
  entityId         String? // Optional: contact may be deleted but message history preserved
  direction        MessageDirection
  channel          MessageChannel   @default(EMAIL)
  subject          String?
  body             String?
  htmlBody         String?
  fromAddress      String
  toAddress        String
  providerId       String? // Gmail message ID or SMTP message ID
  providerData     Json? // Store full provider payload
  messageIdHeader  String? // Message-ID header from email (indexed for efficient reply matching)
  threadId         String? // Gmail thread ID (indexed for efficient reply matching)
  attachments      Json? // Store attachment metadata as JSON
  trackingToken    String?          @unique // Unique token for tracking pixel URL
  openedAt         DateTime? // First time email was opened
  openedCount      Int              @default(0) // Number of times opened
  lastOpenedAt     DateTime? // Most recent open time
  aiClassification String? // DATA, QUESTION, COMPLAINT, ACKNOWLEDGMENT, OTHER
  aiReasoning      String? // Brief explanation of classification
  isAutoReply      Boolean          @default(false) // True if this is an OOO, bounce, or auto-reply
  createdAt        DateTime         @default(now())
  
  // Review workflow fields
  reviewStatus     ReviewStatus     @default(UNREVIEWED)
  reviewedAt       DateTime?
  reviewedById     String?
  reviewNotes      String?

  entity            Entity?            @relation(fields: [entityId], references: [id], onDelete: SetNull)
  task              Task               @relation(fields: [taskId], references: [id], onDelete: Cascade)
  collectedItems    CollectedItem[]    // Evidence/attachments extracted from this message
  reviewedBy        User?              @relation("MessageReviewer", fields: [reviewedById], references: [id])
  auditLogs         ReviewAuditLog[]
  aiRecommendations AIRecommendation[] // AI recommendations for feedback loop

  @@index([taskId])
  @@index([entityId])
  @@index([providerId])
  @@index([taskId, createdAt])
  @@index([trackingToken])
  @@index([messageIdHeader])
  @@index([threadId])
  @@index([isAutoReply])
  @@index([reviewStatus])
}

model AgentSchedule {
  id             String        @id @default(cuid())
  name           String
  cronExpression String
  timezone       String        @default("UTC")
  organizationId String
  groupId        String?
  campaignName   String?
  campaignType   CampaignType?
  emailSubject   String
  emailBody      String
  htmlBody       String?
  lastRunAt      DateTime?
  nextRunAt      DateTime?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  group        Group?       @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([groupId])
  @@index([isActive, nextRunAt])
}

model ConnectedEmailAccount {
  id             String        @id @default(cuid())
  organizationId String
  userId         String?       // User who connected this account (null = legacy/shared)
  email          String
  provider       EmailProvider
  accessToken    String? // Encrypted
  refreshToken   String? // Encrypted
  tokenExpiresAt DateTime?
  syncCursor     Json?
  lastSyncAt     DateTime?
  smtpHost       String?
  smtpPort       Int?
  smtpUser       String?
  smtpPassword   String? // Encrypted
  smtpSecure     Boolean       @default(true)
  isPrimary      Boolean       @default(false)
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User?        @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([userId])
  @@index([email])
  @@index([organizationId, isPrimary])
  @@index([organizationId, userId])
}

model AutomationRule {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  trigger        String // Event that triggers the rule
  conditions     Json // Store conditions as JSON
  actions        Json // Store actions as JSON
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([isActive])
}

model EmailDraft {
  id                    String           @id @default(cuid())
  organizationId        String
  userId                String
  jobId                 String?          // Optional: parent Job for Request-level association
  prompt                String
  generatedSubject      String?
  generatedBody         String?
  generatedHtmlBody     String?
  // Personalization fields
  subjectTemplate       String? // Template with {{Tag Name}} placeholders
  bodyTemplate          String? // Template with {{Tag Name}} placeholders
  htmlBodyTemplate      String? // HTML template with {{Tag Name}} placeholders
  availableTags         Json? // Array of available tag names
  personalizationMode   String? // "none" | "contact" | "csv"
  blockOnMissingValues  Boolean          @default(true)
  deadlineDate          DateTime? // Deadline date for the request (set by user via date picker)
  // Legacy fields (keeping for backwards compatibility)
  suggestedRecipients   Json? // Store suggested entity/group IDs as JSON
  suggestedCampaignName String?
  suggestedCampaignType CampaignType?
  status                EmailDraftStatus @default(DRAFT)
  idempotencyKey        String?          @unique
  aiGenerationStatus    String? // "processing", "complete", "failed", "timeout"
  sentAt                DateTime? // Timestamp when draft was sent (for idempotency)
  sendAttemptId         String? // Unique ID for send attempt tracking
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt

  organization        Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  job                 Job?                  @relation(fields: [jobId], references: [id], onDelete: SetNull)
  personalizationData PersonalizationData[]

  @@index([organizationId])
  @@index([userId])
  @@index([jobId])
  @@index([status])
  @@index([idempotencyKey])
}

model PersonalizationData {
  id             String   @id @default(cuid())
  emailDraftId   String
  recipientEmail String
  contactId      String? // Optional reference to Entity
  dataJson       Json // Key/value map from CSV + contact fields
  renderSubject  String? // Rendered subject for this recipient
  renderBody     String? // Rendered body for this recipient
  renderHtmlBody String? // Rendered HTML body for this recipient
  renderStatus   String? // "ok" | "missing" | "failed"
  renderErrors   Json? // Array of error messages if renderStatus is "failed" or "missing"
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  emailDraft EmailDraft @relation(fields: [emailDraftId], references: [id], onDelete: Cascade)

  @@unique([emailDraftId, recipientEmail])
  @@index([emailDraftId])
  @@index([recipientEmail])
}

model ReminderState {
  id               String    @id @default(cuid())
  taskId           String // Link to Task (the request)
  entityId         String? // Recipient entity (optional: contact may be deleted)
  reminderNumber   Int // Which reminder this is (1, 2, 3, etc.)
  sentCount        Int       @default(0) // How many reminders sent (incremented when sent)
  nextSendAt       DateTime? // When next reminder should be sent (null if stopped or max reached)
  lastSentAt       DateTime? // When last reminder was sent
  stoppedReason    String? // "replied" | "max_reached" | "manual_stop" | null
  scheduledEventId String?   @unique // Inngest event ID for idempotency (prevents duplicate sends)
  organizationId   String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  task   Task    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  entity Entity? @relation(fields: [entityId], references: [id], onDelete: SetNull)

  @@unique([taskId, entityId]) // One state per task+entity
  @@index([taskId])
  @@index([entityId])
  @@index([organizationId, nextSendAt]) // For querying tasks that need reminders
  @@index([scheduledEventId]) // For idempotency checks
}

// CollectedItem represents evidence/attachments received in response to requests
// This is the core model for the Collection feature - request-scoped evidence intake
model CollectedItem {
  id              String              @id @default(cuid())
  organizationId  String
  jobId           String              // Parent checklist item (required)
  taskId          String?             // Optional: specific request/task this came from
  messageId       String?             // Optional: source message if from email
  
  // File metadata
  filename        String
  fileKey         String              // Storage key (blob or local)
  fileUrl         String?             // Cached URL for quick access
  fileSize        Int?                // Bytes
  mimeType        String?
  
  // Source tracking
  source          CollectedItemSource
  submittedBy     String?             // Email address of submitter
  submittedByName String?             // Name if available
  receivedAt      DateTime            // When the item was received
  
  // Approval workflow
  status          CollectedItemStatus @default(UNREVIEWED)
  reviewedBy      String?             // User ID who reviewed
  reviewedAt      DateTime?
  rejectionReason String?
  
  // Metadata
  notes           String?             // Internal notes
  metadata        Json?               // Extensible metadata
  
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  job             Job                 @relation(fields: [jobId], references: [id], onDelete: Cascade)
  task            Task?               @relation(fields: [taskId], references: [id], onDelete: SetNull)
  message         Message?            @relation(fields: [messageId], references: [id], onDelete: SetNull)
  reviewer        User?               @relation("CollectedItemReviewer", fields: [reviewedBy], references: [id])
  
  @@index([organizationId])
  @@index([jobId])
  @@index([taskId])
  @@index([messageId])
  @@index([status])
  @@index([jobId, status])
  @@index([organizationId, jobId])
}

// Board represents a period-based checklist (e.g., "January 2025 Book Close")
// Boards group Jobs for accounting period workflows (Monday.com parity)
model Board {
  id             String        @id @default(cuid())
  organizationId String
  name           String        // "January 2025 Book Close", "Year-End Close 2024"
  description    String?
  status         BoardStatus   @default(NOT_STARTED)
  
  // Ownership (nullable during migration, will become required after data backfill)
  ownerId        String?       // Accountable user for this board
  
  // Time metadata - enables filtering, sorting, and future auto-creation
  cadence        BoardCadence? // Type of time period (Monthly, Weekly, etc.)
  periodStart    DateTime?     // Start of the time period
  periodEnd      DateTime?     // End of the time period
  
  // Automation settings (UI config, automation logic not yet implemented)
  automationEnabled Boolean @default(false) // Auto-create next period's board
  skipWeekends      Boolean @default(true)  // For DAILY cadence: skip weekends
  
  createdById    String
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization   Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  owner          User?               @relation("BoardOwner", fields: [ownerId], references: [id])
  createdBy      User                @relation("BoardCreator", fields: [createdById], references: [id])
  collaborators  BoardCollaborator[]
  jobs           Job[]

  @@index([organizationId])
  @@index([organizationId, status])
  @@index([ownerId])
}

// BoardCollaborator join table for team collaboration on Boards
model BoardCollaborator {
  id        String   @id @default(cuid())
  boardId   String
  userId    String
  role      String   @default("collaborator") // Future: "viewer"
  addedAt   DateTime @default(now())
  addedBy   String   // User.id who added this collaborator

  board Board @relation(fields: [boardId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([boardId, userId])
  @@index([userId])
  @@index([boardId])
}

// Subtask represents a checklist item within a Job (Monday.com subitem parity)
// Subtasks have their own owner, status, due date, and attachments
model Subtask {
  id             String        @id @default(cuid())
  organizationId String
  jobId          String
  title          String
  description    String?
  ownerId        String?       // Nullable - Monday allows unassigned subitems
  status         SubtaskStatus @default(NOT_STARTED)
  dueDate        DateTime?
  sortOrder      Int           @default(0) // Order within job for drag-drop reordering
  completedAt    DateTime?     // Timestamp when marked as DONE
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  job          Job          @relation(fields: [jobId], references: [id], onDelete: Cascade)
  owner        User?        @relation("SubtaskOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  attachments  Attachment[]

  @@index([organizationId])
  @@index([jobId])
  @@index([ownerId])
  @@index([jobId, sortOrder])
}

// Attachment represents a direct file upload on a Job or Subtask
// Distinct from CollectedItem which is for inbound email attachments
model Attachment {
  id             String   @id @default(cuid())
  organizationId String
  jobId          String?  // One of jobId or subtaskId must be set (enforced in app logic)
  subtaskId      String?
  filename       String
  fileKey        String   // Storage key (same pattern as CollectedItem)
  fileUrl        String?  // Cached URL for quick access
  fileSize       Int?     // Bytes
  mimeType       String?
  uploadedById   String
  createdAt      DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  job          Job?         @relation(fields: [jobId], references: [id], onDelete: Cascade)
  subtask      Subtask?     @relation(fields: [subtaskId], references: [id], onDelete: Cascade)
  uploadedBy   User         @relation("AttachmentUploader", fields: [uploadedById], references: [id])

  @@index([organizationId])
  @@index([jobId])
  @@index([subtaskId])
}

// EmailSendAudit provides a persistent audit trail for all email sends
// Critical for debugging, compliance, and customer support
enum EmailSendResult {
  SUCCESS
  FAILED
  BLOCKED
  RATE_LIMITED
  QUEUED  // Email was queued for later due to rate limiting
}

// EmailQueue stores emails that were rate-limited and need to be sent later
// A scheduled job processes this queue when rate limits allow
enum EmailQueueStatus {
  PENDING     // Waiting to be sent
  PROCESSING  // Currently being processed
  SENT        // Successfully sent
  FAILED      // Failed after max retries
  CANCELLED   // Manually cancelled
}

model EmailQueue {
  id              String           @id @default(cuid())
  organizationId  String
  userId          String?          // User who initiated the send
  jobId           String?          // Related job
  taskId          String?          // Related task (if updating existing)
  
  // Email details (stored for retry)
  toEmail         String
  subject         String
  body            String           @db.Text
  htmlBody        String?          @db.Text
  accountId       String?          // Email account to send from
  
  // Queue management
  status          EmailQueueStatus @default(PENDING)
  priority        Int              @default(0)  // Higher = more urgent
  attempts        Int              @default(0)
  maxAttempts     Int              @default(3)
  lastAttemptAt   DateTime?
  nextAttemptAt   DateTime         // When to try sending next
  
  // Error tracking
  lastError       String?
  
  // Metadata for the original send request
  metadata        Json?            // Original send parameters (deadlineDate, remindersConfig, etc.)
  
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  
  organization    Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  @@index([organizationId])
  @@index([status, nextAttemptAt])  // For queue processing
  @@index([toEmail])
  @@index([createdAt])
}

// ReviewAuditLog provides audit trail for review actions
model ReviewAuditLog {
  id              String   @id @default(cuid())
  messageId       String
  userId          String
  action          String   // "marked_reviewed" | "marked_needs_follow_up" | "reply_sent" | "follow_up_created"
  metadata        Json?
  createdAt       DateTime @default(now())
  
  message         Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user            User     @relation("ReviewAuditAuthor", fields: [userId], references: [id])
  
  @@index([messageId])
  @@index([userId])
  @@index([createdAt])
}

model EmailSendAudit {
  id              String          @id @default(cuid())
  organizationId  String
  userId          String?         // User who initiated the send (null for system sends)
  jobId           String?         // Related job if applicable
  taskId          String?         // Related task if applicable
  emailDraftId    String?         // Related email draft if applicable
  
  // Send details
  fromEmail       String
  toEmail         String          // Single recipient (one row per recipient for bulk)
  subject         String
  recipientCount  Int             @default(1) // For bulk sends, total recipients in batch
  
  // Result tracking
  result          EmailSendResult
  errorMessage    String?         // Error details if failed
  errorCode       String?         // Provider error code if available
  
  // Provider details
  provider        EmailProvider?  // GMAIL, MICROSOFT, GENERIC_SMTP
  providerId      String?         // Message ID from provider
  
  // Metadata
  ipAddress       String?         // Request IP for audit
  userAgent       String?         // Request user agent
  metadata        Json?           // Additional context (e.g., personalization mode, reminder number)
  
  createdAt       DateTime        @default(now())
  
  @@index([organizationId])
  @@index([organizationId, createdAt])
  @@index([userId])
  @@index([jobId])
  @@index([taskId])
  @@index([toEmail])
  @@index([result])
  @@index([createdAt])
}

// Column configuration for Monday.com-style configurable task tables
model JobColumnConfig {
  id             String   @id @default(cuid())
  organizationId String   @unique // One config per organization
  boardId        String?  // Optional: board-specific config (null = global default)
  columns        Json     // Array of column definitions: { id, type, label, width, visible, order }
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  @@unique([organizationId, boardId])
  @@index([organizationId])
}

// AI recommendation storage for feedback loop
// Persists AI analysis results and links them to human decisions
model AIRecommendation {
  id                String        @id @default(cuid())
  organizationId    String
  messageId         String
  taskId            String
  
  // Denormalized for metrics queries
  campaignType      CampaignType?
  
  // AI recommendation
  recommendedAction String        // "REVIEWED" | "NEEDS_FOLLOW_UP" (matches ReviewStatus)
  reasoning         String        // Short explanation
  summaryBullets    Json?         // Array of summary points
  findings          Json?         // Array of findings
  
  // Model tracking
  model             String        @default("gpt-4o-mini")
  promptVersion     String        @default("v1")
  
  // Draft reply (generated with memory, persisted for idempotency)
  draftReply        String?       // Pre-filled draft reply text
  draftPromptVersion String?      // Track draft prompt version separately
  
  // Human reconciliation (filled when user acts)
  humanAction       String?       // Actual ReviewStatus chosen
  agreedWithAI      Boolean?      // Computed: recommendedAction == humanAction
  humanActedAt      DateTime?
  
  createdAt         DateTime      @default(now())
  
  message           Message       @relation(fields: [messageId], references: [id], onDelete: Cascade)
  task              Task          @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  @@index([organizationId, createdAt])
  @@index([messageId])
  @@index([organizationId, campaignType, agreedWithAI])
}

// Reconciliation status for the LLM-powered document comparison workflow
enum ReconciliationStatus {
  PENDING      // Documents uploaded, waiting for processing
  PROCESSING   // LLM is analyzing the documents
  COMPLETED    // Analysis complete with results
  FAILED       // Processing failed
}

// Reconciliation represents a comparison between two documents (e.g., Excel spreadsheets)
// Used for AI-powered document reconciliation workflows in accounting
model Reconciliation {
  id             String               @id @default(cuid())
  organizationId String
  jobId          String               // Parent task (Job)
  
  // Document 1 (Source A)
  document1Key   String               // Storage key (blob)
  document1Name  String               // Original filename
  document1Url   String?              // Cached URL for preview
  document1Size  Int?                 // File size in bytes
  
  // Document 2 (Source B)
  document2Key   String               // Storage key (blob)
  document2Name  String               // Original filename
  document2Url   String?              // Cached URL for preview
  document2Size  Int?                 // File size in bytes
  
  // Processing status
  status         ReconciliationStatus @default(PENDING)
  errorMessage   String?              // Error details if failed
  
  // Results (populated after processing)
  summary        String?              // Human-readable summary
  matchedCount   Int?                 // Number of matched items
  unmatchedCount Int?                 // Number of unmatched items
  totalRows      Int?                 // Total rows analyzed
  result         Json?                // Detailed reconciliation result
  discrepancies  Json?                // List of discrepancies found
  
  // Metadata
  createdById    String
  processedAt    DateTime?            // When processing completed
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  
  organization   Organization         @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  job            Job                  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  createdBy      User                 @relation("ReconciliationCreator", fields: [createdById], references: [id])
  
  @@index([organizationId])
  @@index([jobId])
  @@index([status])
  @@index([organizationId, jobId])
}
